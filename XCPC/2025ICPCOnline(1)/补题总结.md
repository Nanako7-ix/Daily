> 赛时六题，唐完了

## A. Who Can Win

直接模拟。是不是以前 xcpc 也出过这样的签到？感觉写起来挺舒服

```cpp
struct status {
	int panelty;
	bool ac;
	status() : panelty(0), ac(false) {}
};

void Thephix() {
	int n;
	cin >> n;
	vector<tuple<string, int, int, string>> submitsions(n);
	for (int i = 0; i < n; ++i) {
		char problem;
		auto& [name, id, t, verdict] = submitsions[i];
		cin >> name >> problem >> t >> verdict;
		id = problem - 'A';
	}
	sort(submitsions.begin(), submitsions.end(),
		[](const auto& x, const auto& y) {
			return get<2>(x) < get<2>(y);
		}
	);

	map<string, array<status, 26>> best, worst;
	for (int i = 0; i < n; ++i) {
		auto& [name, id, t, verdict] = submitsions[i];
		if (!best[name][id].ac) {
			if (verdict == "Accepted" || verdict == "Unknown") {
				best[name][id].ac = 1;
				best[name][id].panelty += t;
			} else {
				best[name][id].panelty += 20;
			}
		}
		if (!worst[name][id].ac) {
			if (verdict == "Accepted") {
				worst[name][id].ac = 1;
				worst[name][id].panelty += t;
			} else {
				worst[name][id].panelty += 20;
			}
		}
	}

	vector<tuple<string, int, int>> teams;
	for (auto [name, dp] : worst) {
		int ac = 0, penalty = 0;
		for (int i = 0; i < 26; ++i) {
			if (dp[i].ac) {
				ac++, penalty += dp[i].panelty;
			}
		}
		teams.emplace_back(name, ac, penalty);
	}

	sort(teams.begin(), teams.end(), [](const auto& x, const auto& y) {
		if (get<1>(x) != get<1>(y)) {
			return get<1>(x) > get<1>(y);
		} return get<2>(x) < get<2>(y);
	});

	for (auto [name, dp] : best) {
		int ac = 0, penalty = 0;
		for (int i = 0; i < 26; ++i) {
			if (dp[i].ac) {
				ac++, penalty += dp[i].panelty;
			}
		}

		int ok = 1;
		for (int i = 0; i < (int) teams.size(); ++i) {
			auto& [_name, _ac, _penalty] = teams[i];
			if (_name == name) continue;
			if (ac < _ac || (ac == _ac && penalty > _penalty)) {
				ok = 0;
			}
			break;
		}

		if (ok) cout << name << " ";
	}
	cout << "\n";
}
```

## B. Creating Chaos

赛时打表发现直接输出 $1$ 到 $k$ 即可。赛后看了一下证明是莫反：

```cpp
void Thephix() {
	int n, k;
	cin >> n >> k;
	for (int i = 1; i <= k; ++i) {
		cout << i << " \n"[i == k];
	}
}
```

## C. Canvas Painting

贪心。这题如果没有转化题意的话还是很难做的。我赛时直接 hack 了两个正确结论（

## D. Min-Max Tree

首先考虑把树划分成若干个连通块，每个连通块的贡献是块内的最大值减最小值带来的。那么你可以考虑把最大值到最小值的路径找出来，然后把这条链单独作为一个连通块，答案一定是不减的。这是**结论一**。所以我一定是考虑若干条链，然后最大值和最小值在端点处取得。

然后考虑一条这样的链，然后从最大值往最小值走的过程中，如果发现了递增的位置，就把它断掉。证明：假设断开的位置是 $x \rightarrow y$ 那么左边部分的贡献是 $\max - x$ 右边部分的贡献是 $y - \min$。这样贡献加起来就是 $\max - \min + y - x$，所以如果 $y \geq x$ 那么把它断掉是对的。这是**结论二**。

所以我们最终的结论是将树划分成若干条单调递减的链。我们考虑一条链的贡献：假设这条链的点权是 $a_1 \rightarrow a_2 \rightarrow \cdots \rightarrow a_k$，且满足 $a_1 > a_2 > \cdots > a_k$，那么这条链的贡献为 $a_1 - a_k$。我们拆一下贡献就有：

$$
a_1 - a_k = (a_1 - a_2) + (a_2 - a_3) + \cdots + (a_{k-1} - a_k)
$$

我们把点权转化到了边权上，所以我们需要做的是，把有向树划分成多条单向链。这里边的方向是从 $a_u \rightarrow a_v$，如果 $a_u \geq a_v$，也就是如果 $a_u = a_v$ 的话，这是双向边。接下来划分成链就使用树形 dp 来做，这个其实是树形 dp 典题了。`dp[u][0/1/2]` 表示 $u$ 这个节点不可延伸/可以往上延伸/可以往下延伸。

他妈的这题赛时一直在想贪心，然后偷听到了旁边队伍的一个 hack 才转头来写 dp。究级战犯啊我。

```cpp
constexpr i64 inf = 4E18;

void Thephix() {
	int n;
	cin >> n;
	vector<int> a(n + 1);
	for (int i = 1; i <= n; ++i) {
		cin >> a[i];
	}
	vector<vector<int>> adj(n + 1);
	for (int i = 1; i < n; ++i) {
		int u, v;
		cin >> u >> v;
		adj[u].push_back(v);
		adj[v].push_back(u);
	}

	vector<array<i64, 3>> dp(n + 1);
	[&](this auto&& dfs, int u, int fa) -> void {
		i64 sum = 0, U = -inf, D = -inf;
		for (auto v : adj[u]) {
			if (v == fa) continue;
			dfs(v, u);
			i64 w_U = a[v] >= a[u] ? a[v] - a[u] : -inf;
			i64 w_D = a[u] >= a[v] ? a[u] - a[v] : -inf;
			sum += dp[v][0];
			U = max(U, dp[v][1] - dp[v][0] + w_U);
			D = max(D, dp[v][2] - dp[v][0] + w_D);
		}
		dp[u] = {
			sum + max(0LL, U) + max(0LL, D),
			sum + max(0LL, U),
			sum + max(0LL, D)
		};
	} (1, 0);

	cout << *max_element(dp[1].begin(), dp[1].end()) << "\n";
}
```

## F. Robot

> 交互题，感觉很变态啊。补题的时候莫名其妙就会了。

首先你需要大致明确围杀机器人的思路：先用一个框把机器人框住，然后再不断二分缩小这个框的范围就能赢了。由于限制使用 $1000$ 次的操作次数，所以这个框注定不会很大。二分的过程很简单，所以关键还是看怎么把机器人框住。

很自然的想法就是用一个正方形围起来。但是机器人太超模了，上下左右都能走！那我能不能限制它只能从上方突破防线，并且我暂时不考虑次数限制。这样就很简单了，我只要在 $y = k$ 的位置设防，我尽量不让机器人跑出去即可。于是我有了第一个策略：每次在机器人的正上方，也就是 $(x, k)$ 的位置涂色。手玩一下发现：涂色永远慢机器人一步。所以一定不是这样涂的，那我们考虑隔一位涂一次？然后你会发现这样是可以的。因为防线的设置速度永远比机器人左右移动的速度要快。所以一定可以构造出这种情况：

```c
x.x.x.x
.......
...o...
```

然后当机器人离防线足够近的时候，填一下中间的漏洞即可。这样就完成了防线的布置。然后再考虑多个方向，依旧暂时不考虑次数限制。我们先按照上面的方式设置防线，由于防线设置的速度是机器人左右移动的速度的两倍，所以一定可以把防线延伸到很远的位置，这个时候我们在很远的位置把右边给封住，赢了（不用给左边和下面设防线是因为第一象限的限制）。对嘛？（其实不是反问，我是真的在问，我不会呜呜呜）

要是遇到了这种情况怎么办：

```c
xxxxx....
....o....
```

你只能在边界的最右边设置防线对吧，那我的机器人一直往右走，你就没有机会给右边设置防线了。而且，你的防线设置地越远，你的防线 $y = k$ 就越大，你的右边防线就要花更多的操作。我不怎么会证明，但是感觉修不完。这个时候就有一个新的想法：反正我防线建这么多也不一定有用，我不妨只在 $x$ 的附近的防线设好即可，这样我每次有空了我就给右边修防线。

> 坏了，上面那个 hack 好像并不成功，感觉是等价的，不管了懒得改了

这个附近需要多大呢？手玩了一下发现好像是 $[x - 4, x + 4]$ 这些位置。大概这样搞一下就做完了。还有一个问题，上面说离防线足够近的时候补充防线，这个到底是多近呢，似乎也是 $4$。

还有一个问题。如果机器人对两个防线的交界处发起进攻，而这个交界处的漏洞特别多，这里是很容易被冲烂的。解决方法是：在游戏开始的时候，先不着急设置上方防线（反正你提前设置也没用，机器人的距离还远）先对这个交界处（正方形的右上角）加强防线。

这样就做完了。我这个解法中，正方形的大小至少开到 $k = 41$。

```cpp
constexpr int n = 41;
int vis[100][100];

void Thephix() {
	int x, y;
	cin >> x >> y;

	auto mark = [&](int i, int j) -> void {
		vis[i][j] = 1;
		cout << i << ' ' << j << endl;
		cin >> x >> y;
		if (x == 0 && y == 0) exit(0);
	};

	mark(n - 4, n), mark(n, n - 4);
	mark(n - 3, n), mark(n, n - 3);
	mark(n - 2, n), mark(n, n - 2);
	mark(n - 1, n), mark(n, n - 1);
	mark(n, n);
	
	while (true) {
		int ok = 0;
		if (n - y <= 4) {
			for (int i : { x, x - 1, x + 1, x - 2, x + 2, x - 3, x + 3, x - 4, x + 4 }) {
				if (i < 1 || i > n) continue;
				if (vis[i][n] == 0) {
					mark(i, n), ok = 1;
					break;
				}
			} if (ok) continue;
		}

		if (n - x <= 4) {
			for (int i : { y, y - 1, y + 1, y - 2, y + 2, y - 3, y + 3, y - 4, y + 4 }) {
				if (i < 1 || i > n) continue;
				if (vis[n][i] == 0) {
					mark(n, i), ok = 1;
					break;
				}
			} if (ok) continue;
		}

		for (int i : { x, x - 2, x + 2, x - 4, x + 4 }) {
			if (i % 2 == 0 || i < 1 || i > n) continue;
			if (vis[i][n] == 0) {
				mark(i, n), ok = 1;
				break;
			}
		} if (ok) continue;

		for (int i : { x - 1, x + 1, x + 3, x - 3 }) {
			if (i % 2 == 0 || i < 1 || i > n) continue;
			if (vis[i][n] == 0) {
				mark(i, n), ok = 1;
				break;
			}
		} if (ok) continue;

		for (int i : { y, y - 2, y + 2, y - 4, y + 4 }) {
			if (i % 2 == 0 || i < 1 || i > n) continue;
			if (vis[n][i] == 0) {
				mark(n, i), ok = 1;
				break;
			}
		} if (ok) continue;

		for (int i : { y - 1, y + 1, y + 3, y - 3 }) {
			if (i % 2 == 0 || i < 1 || i > n) continue;
			if (vis[n][i] == 0) {
				mark(n, i), ok = 1;
				break;
			}
		} if (ok) continue;

		for (int i = 1; i <= n; ++i) {
			if (vis[i][n] == 0) {
				mark(i, n), ok = 1;
				break;
			}
		} if (ok) continue;

		for (int i = 1; i <= n; ++i) {
			if (vis[n][i] == 0) {
				mark(n, i), ok = 1;
				break;
			}
		} if (ok) continue;

		break;
	}

	int l = 1, r = n - 1;
	while (l <= r) {
		int m = (l + r) >> 1;
		for (int i = 1; i < n; ++i) {
			if (vis[m][i] == 0) mark(m, i);
		}
		if (x < m) {
			r = m - 1;
		} else l = m + 1;
	}
}
```

## G. Sorting

目标是对于任意一个 $(i, j)$ 满足 $i < j$，使得 $i$ 可达 $j$。由于连边是从小连向大的，所以对于每个 $u < n$ 都必须满足 $(u, u + 1)$ 存在。直接判这个就行了。

```cpp
void Thephix() {
	int n, m;
	cin >> n >> m;
	vector<int> ok (n);
	for (int i = 1; i <= m; ++i) {
		int u, v;
		cin >> u >> v;
		ok[u] |= v == u + 1;
	}

	if (*min_element(ok.begin() + 1, ok.end())) {
		cout << "Yes\n";
	} else cout << "No\n";
}
```

## I. Knapsack Problem

## J. Moving on the Plane

> 看了题解才会的，笨笨喵。曼哈顿距离和切比雪夫距离可以互相转化，我们可以从两个角度来看待这两类问题。但是一般是困难的，因为你曼哈顿距离转切比雪夫之后，你的思路还是曼哈顿距离的思路。然后就发现两个解法都不会然后就似了。

考虑转化切比雪夫距离。转化后的题意是：每个点进行严格 $m$ 次操作，每次操作是移动一步 $(1, 1), (1, -1), (-1, 1), (-1, -1)$。然后移动之后，对于任意两个点满足 $\max(|x_i - x_j|, |y_i - y_j|) \leq k$。

把这个最大值拆开有 $|x_i - x_j| \leq k$ 且 $|y_i - y_j| \leq k$。你会想，你能不能分开考虑呢？我可以分别计算对这些点进行 $m$ 次操作满足 $|x_i - x_j| \leq k$ 的方案，和 $|y_i - y_j| \leq k$ 的方案组合。你会发现这是可行的。因为考虑 $x$ 的时候，操作变成了 $(1, ?)$ 和 $(-1, ?)$。这是不会影响到对 $y$ 的操作的。

所以接下来考虑这样的问题。给你 $n$ 个点 $|p_i| \leq 2\cdot 10^5$，每次操作可以左右移动一格，问这 $n$ 个点全都分布在一个大小小于等于 $k$ 的区间的方案数。首先我们知道每个点到达坐标轴上的另一个位置 $p_i'$ 的方案数，这个挺简单的，就是一个组合数 $\binom{m}{\frac{m + d}{2}}[m \equiv d \pmod 2]$。

然后我们枚举第一个点出现的位置 $l$。显然所有点只能在 $[l, l + k]$ 出现。然后所有点的出现情况乘在一起就行了。但是会有一个问题：第一个点不一定出现在 $l$ 处啊。

计算所有点同时出现在 $[l + 1, l + k]$ 的情况数量，减去这部分即可。

然后就做完了啦！

```cpp
void Thephix() {
	int n, m, k;
	cin >> n >> m >> k;
	vector<int> x(n + 1), y(n + 1);
	for (int i = 1; i <= n; ++i) {
		cin >> x[i] >> y[i];
		tie(x[i], y[i]) = pair { x[i] + y[i], x[i] - y[i] };
	}

	auto f = [&](const vector<int>& p) -> Z {
		vector<vector<Z>> dp(n + 1, vector<Z> (2 * N + 2));
		for (int i = 1; i <= n; ++i) {
			for (int x = -N; x <= N; ++x) {
				int d = abs(x - p[i]);
				dp[i][x + N + 1] = dp[i][x + N];
				if (m % 2 == d % 2) {
					dp[i][x + N + 1] += comb.C(m, (m - d) / 2);
				}
			}
		}
		Z ans = 0;
		for (int l = -N; l <= N; ++l) {
			int r = min(N, l + k);
			Z res1 = 1, res2 = 1;
			for (int i = 1; i <= n; ++i) {
				res1 *= dp[i][r + N + 1] - dp[i][l - 1 + N + 1];
				res2 *= dp[i][r + N + 1] - dp[i][l + N + 1];
			}
			ans += res1 - res2;
		}
		return ans;
	};
	
	cout << f(x) * f(y) << "\n";
}
```

## M. Teleporter
