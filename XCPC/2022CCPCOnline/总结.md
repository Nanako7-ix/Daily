# 2022 CCPC Online VP & 补题总结

> 数值膨胀了，轻松 rk101 的，怎么现在连 400 都这么难

## C. Guess

> 这是真 guess。这题可能有点绕，可能需要多看几次。

考虑最简单的情况，如果有一方的头顶是奇数，那么第一轮直接结束了。那么很明显的结论是，对于一个数，我只需要考虑它是 $k\cdot 2^x$ 的形式，然后对我们有用的也就是 $x$ 了。我们有这样的一个函数：

```cpp
int f(i64 n) {
	return std::__lg(n & -n);
}
```

这样就是 $x$ 的值了。然后我们用这样的一个二元组来表示游戏的状态：$(x, y)$ 表示 Alice 头顶的数字满足 $f(n) = x$，Bob 头顶的数字满足 $f(m) = y$。那么考虑以下几场游戏的胜负：

$(0, 1)$：Alice 看到了 Bob 头上的数字是 $1$（我们用 $f(x)$ 的方式来代替 $x$，这样比较好描述）不敢确定自己是 $0$ 还是 $2$ 所以 Alice 没说话，这个时候 Bob 看到对方是 $0$，自己一定不可能是 $-1$，所以只能是 $1$，于是 Bob 说出答案，游戏结束。这次游戏：进行了 $2$ 次对话（Alice 和 Bob 各一次）并且 Bob 获胜。

$(1, 0)$：懒得解释了，显然是 $1$ 次对话，Alice 获胜。

$(2, 1)$：Alice 看到了 $1$，和 $(0, 1)$ 的情况相同，Alice 选择了沉默。Bob 看到了 Alice 头上是 $2$，自己头上可能是 $1$ 或者是 $3$，无论什么情况，Alice 第一轮都应该沉默。所以无法根据 Alice 的判断来决定答案，Bob 沉默。这个时候 Alice 发现：我草，Bob 是 $1$，那如果我是 $0$，Bob 就应该 ~~草我~~ 说答案了，但是他没有！说明我不是 $0$，我是 $2$！于是 Alice 说出了答案。总结：$3$ 次对话，Alice 获胜。

$(1, 2)$：Alice 看到了 $2$，自己是 $1$ 或者是 $3$，保持沉默。Bob 看到了 $1$，自己是 $0$ 或者 $2$。但是如果自己是 $0$，那么对方第一次就把我秒了，所以我只能是 $2$。游戏结束，$2$ 次对话，Bob 获胜。

$(3, 2)$：Alice 看到了 $2$，说明自己是 $1$ 或者是 $3$。Alice 第一次保持沉默。Bob 看到对方是 $3$ 说明自己是 $2$ 或者是 $4$，无论如何，对方都应该保持沉默，所以没有理由判断自己的数字，沉默。Alice 回合。假如我现在是 $1$，也就是对方看到了 $1$。那么对方会认为自己是 $0$ 或者是 $2$。那么对方就可以在我第一次沉默之后得到自己是 $2$ 的答案。但是对方选择了沉默。说明我不是 $1$，我是 $3$！游戏结束，$3$ 次对话，Alice 获胜。

$(2, 3)$：Alice 看到了 $3$，没有办法确定自己是 $2$ 还是 $4$，沉默一回合。Bob 看到了 $2$ 说明自己是 $1$ 或者是 $3$。现在 Bob 的心路历程是：假如我是 $1$，那么对方就会认为自己是 $0$ 或者是 $2$，而我这一轮没有给出答案。对方就知道了自己是 $2$。所以如果我是 $1$ 那么对方就会在下一回合结束比赛。现在来到 Alice 的回合。假如自己是 $2$，那么 Bob 无法确定自己是 $1$ 还是 $3$，如果自己是 $4$，那么 Bob 无法确定自己是 $3$ 还是 $5$，所以 Bob 在 Alice 眼中就是应该保持沉默的。Alice 无法做出判断，沉默。Bob 发现对方没有给出答案。那么说明自己不是 $1$，否则 Alice 就会得到答案。所以自己是 $3$。游戏结束，$4$ 次对话，Bob 获胜。

ok，现在来总结一下这六场比赛的规律。

$$
\begin{aligned}
(0, 1) &\rightarrow (2, \operatorname{Bob})\\
(1, 0) &\rightarrow (1, \operatorname{Alice})\\
(2, 1) &\rightarrow (3, \operatorname{Alice})\\
(1, 2) &\rightarrow (2, \operatorname{Bob})\\
(3, 2) &\rightarrow (3, \operatorname{Alice})\\
(2, 3) &\rightarrow (4, \operatorname{Bob})\\
\end{aligned}
$$

容易发现第一个结论：数字大的那个人获胜。然后我们再来看这个对话轮数有什么规律。发现：

$$
\begin{matrix}
(0, 1) & (1, 0) & \rightarrow & [1, 2]\\
(2, 1) & (1, 2) & \rightarrow & [2, 3]\\
(3, 2) & (2, 3) & \rightarrow & [3, 4]\\
\end{matrix}
$$

发现这个范围是 $[\max(f(n), f(m)), \max(f(n), f(m)) + 1]$ 的。然后 Alice 赢就是奇数轮，Bob 赢就是偶数轮（显然）于是我们就可以知道游戏在第几次对话后结束。

我们再根据这个对话次数得到当前的轮数即可。

```cpp
int f(i64 n) {
	return std::__lg(n & -n);
}

void Thephix() {
	i64 n, m;
	cin >> n >> m;
	int l = max(f(n), f(m));
	int r = max(f(n), f(m)) + 1;
	
	int talk;
	if (n > m) {
		talk = l % 2 == 1 ? l : r;
	} else {
		talk = l % 2 == 1 ? r : l;
	}

	cout << (talk + 1) / 2 << ' ' << (n < m) << "\n";
}
```

## H. Mutiple Set

> 怎么会有这么没意思的题

考虑 $x$ 给定时，计算出来的答案时多少。那我们要找 $[l, r]$ 间，$x$ 的倍数有哪些。$x$ 的倍数可以被写为：$k_1x, k_2x, \cdots, k_nx$ 这样的。那么拆贡献容易得到计算出来的答案是这个：

$$
2^{k_n - k_1}\cdot \frac{(k_n - k_1 + 1)\cdot(k_1 + k_n)}{2} \cdot x
$$

其中 $k_1 = \lceil\frac{l}{x}\rceil$，$k_n = \lfloor\frac{r}{x}\rfloor$，于是：

$$
f(x) = 2^{\lfloor\frac{r}{x}\rfloor - \lceil\frac{l}{x}\rceil}\cdot \frac{(\lfloor\frac{r}{x}\rfloor - \lceil\frac{l}{x}\rceil + 1)\cdot(\lceil\frac{l}{x}\rceil + \lfloor\frac{r}{x}\rfloor)}{2} \cdot x
$$

我们需要的是找到所有 $x$ 满足上面的式子。数论分块学的好的同学一眼秒了：直接按段枚举 $x$ 使得区间内 $\lceil\frac{l}{x}\rceil$ 和 $\lfloor\frac{r}{x}\rfloor$ 都相等。然后计算出 $\frac{f(x)}{x}$ 也就是左边那一大坨。如果 $k$ 是这一坨的倍数，那么可以解得一个 $x$。**需要判断这里 $x$ 的确在区间内，赛时一直在调这个他妈的**。然后这样做的时间复杂度是根号的，卡卡过了！

坏消息是，他妈的没卡过去。

于是队友给了另一个思路：$x$ 一定是 $k$ 的因子！pollard rho 暴力分解 k 的所有因子 $x$，$O(1)$ 计算 $f(x)$，判断 $x$ 是否满足要求，做完了，时间复杂度 $O(k^{\frac{1}{4}} + d(k))$。

所以，这种题有什么意思吗。
