## C. Jiaxun!

> 最需要加训的一集。玉玉了。

最大化最小值，直接触发二分关键字了。考虑二分，范围是 $l = 0, r= \lfloor\frac{sum}{3}\rfloor$，只需要考虑如何 check。

赛时队友说贪心不能 check，用网络流做的。事实上这个**分配任务**确实非常网络流啊。所以：

```cpp
void Thephix() {
	int sum;
	array<int, 8> f {};

	cin >> sum;
	for (int i = 1; i < 8; ++i) {
		cin >> f[i];
	}

	MaxFlow<int> g(9);
	int s = 8, t = 9;
	g.add(s, 4, f[3]), g.add(4, 1, inf), g.add(4, 2, inf);
	g.add(s, 5, f[5]), g.add(5, 1, inf), g.add(5, 3, inf);
	g.add(s, 6, f[6]), g.add(6, 2, inf), g.add(6, 3, inf);
	g.add(s, 7, f[7]), g.add(7, 1, inf), g.add(7, 2, inf), g.add(7, 3, inf);

	auto check = [&](int x) -> bool {
		array<int, 3> need {
			max(x - f[1], 0),
			max(x - f[2], 0),
			max(x - f[4], 0)
		};

		auto G = g;
		G.add(1, t, need[0]);
		G.add(2, t, need[1]);
		G.add(3, t, need[2]);

		return G.flow(s, t) == need[0] + need[1] + need[2];
	};

	int l = 0, r = sum / 3, res = -1;
	while (l <= r) {
		int m = (l + r) >> 1;
		if (check(m)) {
			res = m, l = m + 1;
		} else r = m - 1;
	}

	cout << res << "\n";
}
```

贪心解：hall

就过了，似乎赛时还卡了一下时间。

## E. Zero

> 赛时直接秒，写的很爽的一题

我们考虑我们所构造出来的数组的异或前缀和数组，那么每一个前缀和数组都和一个原数组一一对应。那么我们现在的目标就是我们能构造出多少个前缀和数组。

先转化一下条件，我们需要构造一个长度为 $n + 1$ 的数组，其中满足 $\operatorname{pre}(0) = \operatorname{pre}(n) = 0$。这对应了前缀和数组的定义以及要求数组异或和为 $0$ 的要求。然后再看第二个条件：相邻两个数字不相等。而如果相邻两个数字相等：$a_i = a_{i + 1}$ 那么 $\operatorname{pre}(i + 1) = \operatorname{pre}(i - 1)$。这是一个充要条件。然后再看一下值域，如果原数组里面的数都是 $[0, 2^m)$ 的，等价于前缀和数组的数字是 $[0, 2^m)$ 的。

所以我们的目标就是构造一个长度为 $n + 1$ 的数组，值域为 $[0, 2^m)$（下面令 $x = 2^m$），满足 $a(0) = a(n) = 0$，并且间隔一位不相等。考虑到这个范围很大，非常不好做，而且我是推式子飞舞。但是这个条件给的非常 dp，我们尝试一下能不能用 dp + 矩阵快速幂加速 dp 来解决这题。

考虑我 append 一个数字，那么我需要知道当前数组的倒数第二位是什么。而倒数第一位是下一次 append 需要用到的，所以我们就这样设置 dp 状态：

$$
\operatorname{dp}(i, a_{i - 1}, a_i)
$$

表示当前数组长度为 $i + 1$（也就是最后一位是数组的第 $i$ 个位置），最后一位为 $a_i$，倒数第二位为 $a_{i - 1}$ 的情况有多少种。那么我们最后需要的就是 $\operatorname{dp}(n, *, 0)$。如果数据范围很小，那么这就直接做完了。但是 $n$ 很大，我们考虑使用矩阵加速，事实上这个矩阵也是非常好写的。$m$ 很大，我们考虑不直接使用 $a_i$ 的具体值作为 dp 函数的参数。

注意到我们最终需要的是 $\operatorname{dp}(n, *, 0)$，那么我们直接考虑 $a_i$ 为 $0$ 或者非 $0$。现在这个矩阵还好写吗？答案是好写的，你可以自己尝试一下，这里不给出 $16$ 个项的具体计算方式，只给出结果自行理解一下。

$$
\left [
\begin{matrix}
  0   &   1   &   0   &   0  \\
  0   &   0   &   0   &   1  \\
x - 1 & x - 2 &   0   &   0  \\
  0   &   0   & x - 1 & x - 2\\
\end{matrix}
\right ]
\cdot
\left [
\begin{matrix}
&\operatorname{dp}(i, 0, 0)&\\
&\operatorname{dp}(i, 1, 0)&\\
&\operatorname{dp}(i, 0, 1)&\\
&\operatorname{dp}(i, 1, 1)&\\
\end{matrix}
\right ]
=
\left [
\begin{matrix}
&\operatorname{dp}(i + 1, 0, 0)&\\
&\operatorname{dp}(i + 1, 1, 0)&\\
&\operatorname{dp}(i + 1, 0, 1)&\\
&\operatorname{dp}(i + 1, 1, 1)&\\
\end{matrix}
\right ]
$$

我们最初的向量满足：

$$
\operatorname{dp}(1) =
\left [
\begin{matrix}
1\\
0\\
x-1\\
0\\
\end{matrix}
\right ]
$$

通过矩阵快速幂计算出：

$$
\operatorname{dp}(n) = M^{n-1} \operatorname{dp}(1)
$$

即可。
