## C. Jiaxun!

> 最需要加训的一集。玉玉了。

最大化最小值，直接触发二分关键字了。考虑二分，范围是 $l = 0, r= \lfloor\frac{sum}{3}\rfloor$，只需要考虑如何 check。

赛时队友说贪心不能 check，用网络流做的。事实上这个**分配任务**确实非常网络流啊。所以：

```cpp
void Thephix() {
	int sum;
	array<int, 8> f {};

	cin >> sum;
	for (int i = 1; i < 8; ++i) {
		cin >> f[i];
	}

	MaxFlow<int> g(9);
	int s = 8, t = 9;
	g.add(s, 4, f[3]), g.add(4, 1, inf), g.add(4, 2, inf);
	g.add(s, 5, f[5]), g.add(5, 1, inf), g.add(5, 3, inf);
	g.add(s, 6, f[6]), g.add(6, 2, inf), g.add(6, 3, inf);
	g.add(s, 7, f[7]), g.add(7, 1, inf), g.add(7, 2, inf), g.add(7, 3, inf);

	auto check = [&](int x) -> bool {
		array<int, 3> need {
			max(x - f[1], 0),
			max(x - f[2], 0),
			max(x - f[4], 0)
		};

		auto G = g;
		G.add(1, t, need[0]);
		G.add(2, t, need[1]);
		G.add(3, t, need[2]);

		return G.flow(s, t) == need[0] + need[1] + need[2];
	};

	int l = 0, r = sum / 3, res = -1;
	while (l <= r) {
		int m = (l + r) >> 1;
		if (check(m)) {
			res = m, l = m + 1;
		} else r = m - 1;
	}

	cout << res << "\n";
}
```

就过了，似乎赛时还卡了一下时间。

贪心解：hall 定理。

先描述一下 hall 定理的内容：

考虑一个二分图 $(L + R, E)$，考虑 $L$ 或 $R$ 的一个子集 $S$。$S$ 存在一个大小为 $|S|$ 的匹配当且仅当对于任意一个 $T \subseteq S$ 满足 $|N(T)| \geq |T|$ 其中 $N(T)$ 表示 $\bigcup\limits_{v\in T} \operatorname{adj}(v)$。

好像后面的建模和原理有点懒得解释了。直接放代码：

```cpp
void __Thephix() {
	array<int, 1 << n> f {};
	for (int i = 0; i < (1 << n); ++i) {
		cin >> f[i];
	}

	int x = inf;
	for (int s = 1; s < (1 << n); ++s) {
		int sum = 0;
		for (int t = 1; t < (1 << n); ++t) {
			if (t & s) sum += f[t];
		}
		x = min(x, sum / popcount<u32>(s));
	}

	cout << x << "\n";
}
```

## D. Arcane Behemoths

> 傻逼。拆贡献典中典中典题。为什么我能推不出来式子？？

题目要求对于所有子序列，求这个子序列的贡献。考虑一个子序列：$s_1 \leq s_2 \leq \cdots \leq s_k$。一定是从小到大操作的，所以这个子序列的贡献是：

$$
s_1 + \sum_{i = 2}^k s_i \cdot 2^{i - 2}
$$

把上面的式子拆成两个部分。其中第一个部分是：

$$
\sum_{\operatorname{subsequence}} \min(\operatorname{subsequence})
$$

对于这一部分，我们考虑枚举 $a_i$，然后 $a_i$ 这一项的贡献是 

$$
a_i\sum\limits_{\operatorname{subsequence}} [a_i = \min(\operatorname{subsequence})]
$$

考虑把 $a$ 按降序排列，简单计数后 $a_i$ 的贡献为 $2^{i - 1}\cdot a_i$。

接下来再考虑第二部分，$a_p$ 的贡献为：

$$
\begin{aligned}
&\sum_{i = 1}^{n - p} ((a_p\cdot 2^{i-1})\cdot 2^{p-1} \binom{n - p}{i})\\
=&2^{p-1}\cdot a_p\sum_{i=1}^{n-p}\binom{n-p}{i}\cdot 2^{i-1}
\end{aligned}
$$

其中这里 $i$ 指的是子序列中，小于 $a_p$ 的数有 $i$ 个。这一大块求和其实就是一个二项式定理。

$$
\begin{aligned}
&\sum_{i=1}^{n-p}\binom{n-p}{i}\cdot 2^{i - 1}\\
=& \frac{1}{2}\cdot\sum_{i=1}^{n-p}\binom{n-p}{i}\cdot 2^{i}\\
=& \frac{1}{2}\cdot(\sum_{i=0}^{n-p}\binom{n-p}{i}\cdot 2^{i} - 1)\\
=& \frac{1}{2}\cdot(3^{n-p} - 1)\\
\end{aligned}
$$

把两个部分加起来即为 $a_p$ 的贡献，枚举 $p$ 计算即可。

## E. Zero

> 赛时直接秒，写的很爽的一题

我们考虑我们所构造出来的数组的异或前缀和数组，那么每一个前缀和数组都和一个原数组一一对应。那么我们现在的目标就是我们能构造出多少个前缀和数组。

先转化一下条件，我们需要构造一个长度为 $n + 1$ 的数组，其中满足 $\operatorname{pre}(0) = \operatorname{pre}(n) = 0$。这对应了前缀和数组的定义以及要求数组异或和为 $0$ 的要求。然后再看第二个条件：相邻两个数字不相等。而如果相邻两个数字相等：$a_i = a_{i + 1}$ 那么 $\operatorname{pre}(i + 1) = \operatorname{pre}(i - 1)$。这是一个充要条件。然后再看一下值域，如果原数组里面的数都是 $[0, 2^m)$ 的，等价于前缀和数组的数字是 $[0, 2^m)$ 的。

所以我们的目标就是构造一个长度为 $n + 1$ 的数组，值域为 $[0, 2^m)$（下面令 $x = 2^m$），满足 $a(0) = a(n) = 0$，并且间隔一位不相等。考虑到这个范围很大，非常不好做，而且我是推式子飞舞。但是这个条件给的非常 dp，我们尝试一下能不能用 dp + 矩阵快速幂加速 dp 来解决这题。

考虑我 append 一个数字，那么我需要知道当前数组的倒数第二位是什么。而倒数第一位是下一次 append 需要用到的，所以我们就这样设置 dp 状态：

$$
\operatorname{dp}(i, a_{i - 1}, a_i)
$$

表示当前数组长度为 $i + 1$（也就是最后一位是数组的第 $i$ 个位置），最后一位为 $a_i$，倒数第二位为 $a_{i - 1}$ 的情况有多少种。那么我们最后需要的就是 $\operatorname{dp}(n, *, 0)$。如果数据范围很小，那么这就直接做完了。但是 $n$ 很大，我们考虑使用矩阵加速，事实上这个矩阵也是非常好写的。$m$ 很大，我们考虑不直接使用 $a_i$ 的具体值作为 dp 函数的参数。

注意到我们最终需要的是 $\operatorname{dp}(n, *, 0)$，那么我们直接考虑 $a_i$ 为 $0$ 或者非 $0$。现在这个矩阵还好写吗？答案是好写的，你可以自己尝试一下，这里不给出 $16$ 个项的具体计算方式，只给出结果自行理解一下。

$$
\left [
\begin{matrix}
  0   &   1   &   0   &   0  \\
  0   &   0   &   0   &   1  \\
x - 1 & x - 2 &   0   &   0  \\
  0   &   0   & x - 1 & x - 2\\
\end{matrix}
\right ]
\cdot
\left [
\begin{matrix}
&\operatorname{dp}(i, 0, 0)&\\
&\operatorname{dp}(i, 1, 0)&\\
&\operatorname{dp}(i, 0, 1)&\\
&\operatorname{dp}(i, 1, 1)&\\
\end{matrix}
\right ]
=
\left [
\begin{matrix}
&\operatorname{dp}(i + 1, 0, 0)&\\
&\operatorname{dp}(i + 1, 1, 0)&\\
&\operatorname{dp}(i + 1, 0, 1)&\\
&\operatorname{dp}(i + 1, 1, 1)&\\
\end{matrix}
\right ]
$$

我们最初的向量满足：

$$
\operatorname{dp}(1) =
\left [
\begin{matrix}
1\\
0\\
x-1\\
0\\
\end{matrix}
\right ]
$$

通过矩阵快速幂计算出：

$$
\operatorname{dp}(n) = M^{n-1} \operatorname{dp}(1)
$$

即可。

## I. DAG Query

> 出诈骗题，太变态了我草

考虑一条路径，路径长度（边数）为 $k$ 的时候，他在贡献从 $x$ 变成了 $x\cdot c^k$。

考虑 $g(k)$ 为从 $s$ 到 $t$ 的所有长度为 $k$ 的路径的贡献和，那么

$$
f(s, t, c) = \sum\limits_{k=0}^{n-1} g(k)\cdot c^k
$$

我们考虑 $s = 1,t = n$，令 $f(s, t, x) = f(x)$，那么：

$$
f(x) = \sum\limits_{k=0}^{n-1} g(k)\cdot x^k
$$

这是一个 $n - 1$ 次多项式，我们有 $999$ 次操作。也就是我有 $999$ 个点，只能确定 $998$ 次多项式，当 $n = 1000$ 的时候就似了。我草我是傻逼，$f(0) = [n = 1]$，所以是 $1000$ 个点，解决 $n - 1$ 次多项式是对的。其实题目没有 $n = 1$ 的数据，不然这题真的太恶心了。
