# The 2022 ICPC Asia Regionals Online Contest (II)

> 打的好像不是很好，感觉那个容斥能开的，那个排列计数的读题读少了一个条件，重大失误。然后最终好像是 rk300 左右。

## J. A Game about Increasing Sequences

直接 dfs 暴力枚举当前选左边的数还是右边的数。这样做总共有 $n^2$ 个状态，就算使用记忆化搜索也会 $O(n^2)$ 的。不妨考虑这里的转移有什么特点。假如左边可以选择的数字是 $x$，右边可以选择的数字是 $y$。不妨设 $x \leq y$，这样如果我选了 $y$，以后的不可能取左边的数了，也就是剩下的操作都是固定的了。如果我们这个时候可以直接知道剩下还有多少个数字可以选，那么就可以在这个地方剪枝。因为如果你还有奇数个位置可以选，那么后手必胜，否则先手必胜。

我们可以预处理从左边和右边出发，遇到的第一个单调不增的位置在哪，这样就可以完成我们的剪枝了。由于每次都选择小的那个数才能继续搜索下去，所以递归树的深度为 $n$，而不走这条路径的方向都会第一时间被剪枝。所以总时间复杂度为 $O(n)$

如果先手必胜当且仅当存在一个后继状态为先手必败状态。

```cpp
void Thephix() {
	int n;
	cin >> n;
	vector<int> a(n + 1);
	for (int i = 1; i <= n; ++i) {
		cin >> a[i];
	}

	int lft = 1, rgt = n;
	for (int i = 2; i <= n; ++i) {
		if (a[i] > a[lft]) {
			lft++;
		} else break;
	}
	for (int i = n - 1; i >= 1; --i) {
		if (a[i] > a[rgt]) {
			rgt--;
		} else break;
	}

	auto win = [&](auto&& win, int x, int y) -> bool {
		if (x + 1 == y) return false;
		int Max = max(x >= 1 ? a[x] : 0, y <= n ? a[y] : 0);
		
		int ok = 0;
		if (a[x + 1] > Max && a[y - 1] > Max) {
			ok |= !win(win, x + 1, y);
			ok |= !win(win, x, y - 1);
		} else if (a[x + 1] > Max) {
			ok |= (lft - x) & 1;
		} else if (a[y - 1] > Max) {
			ok |= (y - rgt) & 1;
		}
		return ok;
	};

	if (win(win, 0, n + 1)) {
		cout << "Alice\n";
	} else {
		cout << "Bob\n";
	}
}
```

## G. Good Permutation

妈的，赛时没有看到区间要么包含要么不交的条件。

首先这题肯定是给定的区间必须是值域内连续的一块。所以我对于每个区间，我考虑把至于内的数选一些分给子区间，然后子区间方案数乘上这个分配的方案情况，就得到了当前区间的方案数了。而子区间的方案数又是一个子问题，所以我们可以在考虑把这个问题弄成一棵树来做。

考虑如何把值域内的数分配给子区间。由于子区间一定是选择一个连续的段，这样就是隔板法了。我们令 rest 表示区间中剩下的没有被分配的数的个数，cnt 表示子区间的个数。把子区间视作隔板，剩余的数视为被分配的元素，也就是相同的小球。这样我们的方案数是 $\binom{\operatorname{rest} + \operatorname{cnt}}{\operatorname{cnt}}$。然后这些相同的小球实际上不同，所以我们把它排列一下，方案数是 $\operatorname{rest}!$。同理，这些区间具体被分到哪些值域上也需要被排列，所以方案数是 $\operatorname{cnt}!$。所以总方案数是 $(\operatorname{rest} + \operatorname{cnt})!$。

以上是赛时的解法。其实感觉自己唐完了。把子区间看成一个整体，这样你就有 $\operatorname{rest} + \operatorname{cnt}$ 个块需要被分配，这样的话就是排列一下就行了。

```cpp
void Thephix() {
	int n, m;
	cin >> n >> m;
	vector<array<int, 2>> a(m + 1);
	a[0] = { 1, n };
	for (int i = 1; i <= m; ++i) {
		auto& [l, r] = a[i];
		cin >> l >> r;
	}

	vector<int> id(m + 1);
	iota(id.begin(), id.end(), 0);
	sort(id.begin() + 1, id.end(), [&](int i, int j) {
		if (a[i][0] != a[j][0]) {
			return a[i][0] < a[j][0];
		} return a[i][1] > a[j][1];
	});
	
	vector<int> stk {0};
	vector<vector<int>> adj(m + 1);
	for (int i = 1; i <= m; ++i) {
		int u = id[i];
		auto& [l, r] = a[u];
		while (l > a[stk.back()][1]) {
			stk.pop_back();
		}
		adj[stk.back()].push_back(u);
		stk.push_back(u);
	}

	auto dfs = [&](auto&& dfs, int u) -> Z {
		Z ans = 1;
		int x = a[u][1] - a[u][0] + 1;
		for (auto v : adj[u]) {
			x -= a[v][1] - a[v][0];
			ans *= dfs(dfs, v);
		}
		return ans * comb.fac(x);
	};

	cout << dfs(dfs, 0) << "\n";
}
```

## B. Non-decreasing Array

我们需要最大化 $\sum\limits_{i = 2}^m (a_i - a_{i - 1})^2$。现在考虑我的操作中的第二个步骤应该怎么做比较好，这里直接被队友喂了一个结论就是如果需要对 $i$ 执行修改操作，那么最优一定是把 $a_i$ 变成 $a_{i - 1}$ 或者 $a_{i + 1}$。我们再计算一下变成 $a_{i - 1}$ 或者 $a_{i + 1}$ 的时候的贡献，发现这刚好等价于把 $a_i$ 删掉。于是我们猜测：每次操作相等于删除两个数字。

我们很容易可以证明这个是可以做到的。我们假设我们现在的每次操作是删除两个数字，现在我们证明这个操作等价于题目中给出的操作。假设我们现在需要操作 $k$ 次，我们找到我们需要删除的 $2k$ 个位置，然后从左到右依次对每个位置执行：删除，修改，删除，修改...。这是可以做到的，结果发现：通过题目所给的操作，是可以做到这个答案的。所以我们求的答案一定大于等于删除 $2k$ 个位置的答案。又因为删除操作一定不劣于修改操作，所以这就是我们需要的答案。

妈的讲的有点绕，反正我自己懂了。

然后现在需要做的是，删除 $x$ 个数字，怎么最大化那一坨式子。好像贪心是错的，但是没有想到怎么证明。这里给出 dp 的解法。我们考虑保留 $x$ 个数字的情况，那么我们最终需要的就是保留 $\max(2, n - 2k)$ 个数字的答案。我们考虑 $f(i, j)$ 表示保留 $j$ 个数字，并且以 $a_i$ 结尾的方案中最大的贡献。这个 dp 挺简单的不想写了。

```cpp
void Thephix() {
	int n;
	cin >> n;
	vector<i64> a(n + 1);
	for (int i = 1; i <= n; ++i) {
		cin >> a[i];
	}

	auto f = [&](int x, int y) -> i64 {
		return (a[x] - a[y]) * (a[x] - a[y]);
	};

	vector dp(n + 1, vector<i64> (n + 1, -inf));
	dp[1][1] = 0;
	for (int i = 2; i <= n; ++i) {
		for (int j = 2; j <= i; ++j) {
			for (int k = 1; k < i; ++k) {
				dp[i][j] = max(dp[i][j], dp[k][j - 1] + f(i, k));
			}
		}
	}

	for (int k = 1; k <= n; ++k) {
		cout << dp[n][max(2, n - 2 * k)] << "\n";
	}
}
```

## L. Quadruple

赛时的解法是：构造自动机，这是一个 $5 \times 5$ 的矩阵，对于 ICPC 中的每一个字母，我们都可以构造出相应的矩阵。这样我们就变成了一个矩阵优化 dp 的形式，然后发现矩阵可逆，可以使用前缀和解决。如果范围小一点并且带修，这就变成了一个 ddp 问题，使用线段树维护转移矩阵解决。这种思路还是熟悉一下不然到时候似了想不到。这样我们的时间复杂度是 $O(5^3 (n + q))$ 的，这题好像卡了这个解法。但是还是要写这个写法qwq。

说明需要一个矩阵的板子了，然后需要**注意矩阵的乘法顺序**。

那么这题的正解是怎么做的呢。我们需要的是 $[l, r]$ 区间的 ICPC 子序列的数量，那么它等于区间 $[1, r]$ 的 ICPC 的数量减去 $[1, l)$ 的 ICPC 的数量，再减去那些 I+CPC，IC+PC，ICP+C 的情况。对于 $[l, r]$ 区间的 CPC 和 PC 子序列的出现次数，我们使用类似的方式解决。

这个容斥思路其实挺常见的，但是确实不好想。这种思路我们平时遇到的都是：恰好为 $k$ 的不好做，那我们就转化成 $\leq k$ 的来计算，然后再减去。这个也是类似的，也是转化前缀和然后容斥的思路，不过这个要像分治一样考虑跨区间的就比较恶心。

```cpp
using Z = ModInt<u32, 998244353>;

void Thephix() {
	int n, q;
	string s;
	cin >> n >> q >> s;

	i64 x, a, b, p;
	cin >> x >> a >> b >> p;
	vector<array<int, 2>> f(q + 1);
	for (int i = 1; i <= q; ++i) {
		x = (a * x + b) % p;
		f[i][0] = x % n + 1;
	}
	for (int i = 1; i <= q; ++i) {
		x = (a * x + b) % p;
		f[i][1] = x % n + 1;
		if (f[i][0] > f[i][1]) {
			swap(f[i][0], f[i][1]);
		}
	}

	vector<vector<Z>> dp(n + 1, vector<Z> (1 << k));
	dp[0][0] = 1;
	for (int i = 1; i <= n; ++i) {
		char ch = s[i - 1];
		dp[i] = dp[i - 1];
		for (int s = 1; s < (1 << k); ++s) {
			int p = __lg(s);
			if (ch == t[p]) {
				dp[i][s] += dp[i - 1][s ^ (1 << __lg(s))];
			}
		}
	}

	Z ans = 0;
	for (int i = 1; i <= q; ++i) {
		auto [l, r] = f[i];
		Z   PC = dp[r][12] - dp[l - 1][12] - dp[l - 1][4] * (dp[r][8] - dp[l - 1][8]);
		Z  CPC = dp[r][14] - dp[l - 1][14] - dp[l - 1][2] *  PC - dp[l - 1][6] * (dp[r][8] - dp[l - 1][8]);
		Z ICPC = dp[r][15] - dp[l - 1][15] - dp[l - 1][1] * CPC - dp[l - 1][3] * PC - dp[l - 1][7] * (dp[r][8] - dp[l - 1][8]);
		ans += ICPC;
	}
	cout << ans << "\n";
}
```

## E. An Interesting Sequence

> 他妈的喜欢在签到题写一堆唐氏东西

好像赛时是一发过的，我当时在看博弈。赛后补题感觉唐完了。我构造了一个

$$
\begin{matrix}
k & p & p - 1 & p - 2 & \cdots & 2 & 3 & 2 & 3 &\cdots
\end{matrix}
$$

实际上应该是：

$$
\begin{matrix}
k & p & 2 & 3 & 2 & 3 &\cdots
\end{matrix}
$$

这里需要特判 $p = 2$ 的情况。

```cpp
void Thephix() {
	int n, k;
	cin >> n >> k;

	int p = -1;
	for (int i = 2; true; ++i) {
		if (gcd(i, k) == 1) {
			p = i; break;
		}
	}

	i64 ans = k;
	if (p == 2) n--;
	else n -= 2, ans += p;
	cout << ans + (n + 1) / 2 * 2 + n / 2 * 3 << "\n";
}
```

## A. Yet Another Remainder

赛时我在看计数，队友写的。我当时还以为是什么神秘容斥什么的。实际上是费马小定理。

告诉我费马小定理之后就会做了，秒了，爆简单啊，怎么我想不到的。玉玉了。

```cpp
int power(int a, int b, int p) {
	int res = 1;
	for (a %= p; b; b >>= 1, a = a * a % p) {
		if (b & 1) res = res * a % p;
	}
	return res;
}

void Thephix() {
	int n, m;
	cin >> n;
	m = min(100, n);
	vector<vector<i64>> f(m + 1);
	for (int i = 1; i <= m; ++i) {
		f[i].assign(i + 1, 0);
		for (int j = 1; j <= i; ++j) {
			cin >> f[i][j];
		}
	}

	int q;
	cin >> q;
	while (q--) {
		int p;
		cin >> p;
		i64 ans = 0;
		if (n <= 100) {
			auto& a = f[m];
			for (int i = 1; i <= m; ++i) {
				ans += a[i] * power(10, n - i, p) % p;
				ans %= p;
			}
		} else {
			auto& a = f[p - 1];
			for (int i = 1; i <= p - 1; ++i) {
				ans += a[i] * power(10, (n - i) % (p - 1), p);
				ans %= p;
			}
		}
		cout << ans << '\n';
	}
}
```
