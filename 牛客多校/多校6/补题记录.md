# 牛客多校 6 补题总结

以个人体感难度排序，可能存在个人差。[传送门](https://ac.nowcoder.com/acm/contest/108303)

## L. Minimum Parenthesis String

构造长度为 $2n$ 的最小的合法括号序，满足给定的 $m$ 的区间中，每个区间都至少包含一个左括号。

考虑贪心，如果不考虑区间的限制，显然左半边放左括号，右半边放右括号是最优的。这些区间的限制就是我们必须把前半部分的括号交换到后面，每次交换显然交换最后一个左括号。每次交换都会使得前面的左括号数量减小，也就是字典序减小，所以我们应该优先尽可能少交换。怎么尽可能少交换呢，我们直接倒序枚举区间，当下一个区间的右端点比之前区间的左端点要小的时候，结算右边的区间即可。

最后 check 一下通过这种方式构造出来的括号序是否合法。如果不合法就一定没有合法的了，因为这是尽可能让字典序最小的，也就是左括号尽可能在左边。如果这种情况都不行，那把其他的左括号放到右边就更不行了。所以实际上最小和合法是两个相似的要求。

```cpp
void Thephix() {
    int n, m;
    cin >> n >> m;
    vector<array<int, 2>> a(m + 1);
    for (int i = 1; i <= m; ++i) {
        cin >> a[i][0] >> a[i][1];
    }
    sort(a.begin() + 1, a.end(), [](const array<int, 2>& x, const array<int, 2>& y) {
        return x[1] > y[1];
    });
    
    string s = " " + string(n, '(') + string(n, ')');
    
    for (int i = 1, j = n, Max = -1; i <= m; ++i) {
        auto [l, r] = a[i];
        if (r < Max) {
            if (j <= 0) {
                cout << "-1\n";
                return;
            }
            swap(s[j], s[Max]);
            j--, Max = -1;
        }
        Max = max(Max, l);
        if (i == m) {
            if (j <= 0) {
                cout << "-1\n";
                return;
            }
            swap(s[j], s[Max]);
            j--, Max = -1;
        }
    }
    
    auto check = [&]() -> bool {
        vector<int> f(2 * n + 1);
        for (int i = 1; i <= 2 * n; ++i) {
            f[i] = s[i] == ')' ? -1 : 1;
            f[i] += f[i - 1];
            if (f[i] < 0) return false;
        }
        return true;
    };
    
    if (check()) {
        cout << s.substr(1) << "\n";
    } else {
        cout << "-1\n";
    }
}
```

## K. Maximum GCD

选择一个区间进行区间加，问区间加之后的数组的 gcd 最大是多少。先考虑我们操作的这个区间的答案，也就是区间 gcd。首先是一个 gcd 的常见结论：$\gcd(x, y) = \gcd(x, y - x)$。而区间加不会改变区间中任意两个数的差值，所以我们可以考虑通过这个性质来求解区间 gcd。

首先我们注意到如果区间中的数字相同的话，是可以做到区间 gcd 为 $\infty$ 的，而如果区间中只有两个数，那么区间的 gcd 一定会是 $|x-y|$ 的因子。类似地，我们可以得出在若干个数字的时候，区间 gcd 一定是

$$
d = \gcd\limits_{i = l+1}^{r}a_i - a_{i-1}
$$

的因子。事实上，我们可以通过区间加来使得区间 gcd 等于 $d$。操作起来很简单，只需要让最小的那个数变成 $d$ 的倍数。由于任意两个数的差值都是 $d$ 的倍数，所以每个数都是 $d$ 的倍数，这样区间 gcd 就是 $d$ 的倍数了。即使因数又是倍数，那区间 gcd 就是 $d$ 了。

于是你学会了 $n^2 \log n$ 的解法。枚举区间，对这个区间执行区间加后所能得到的最大全局 gcd 为：前缀 gcd，后缀 gcd，以及差分数组的区间 gcd 三者的 gcd。

前缀 gcd 和后缀 gcd 可以预处理，区间 gcd 用 ST 表解决。

这个时间复杂度太大了，怎么优化呢。计算答案的时间复杂度已经很优了，只能考虑优化枚举区间。这个时候有 gcd 的一个经典结论：累计的 gcd 最多变化 $\log$ 次。

累计的 gcd 就是像这里的前缀 gcd 和后缀 gcd 一样，每次都从前面的 gcd 继承过来。这样 gcd 每次变化，每次变化都会让 gcd 的质因子幂次和至少减 $1$。而 gcd 的质因子幂次和是 $\log$ 级别的。

所以我们可以把枚举 $l, r$ 改成只需要考虑使得 $\operatorname{pre}(l) = x$ 的最大的 $l$ 和使得 $\operatorname{suf}(r) = y$ 的最小的 $r$ 即可。这样实际上只会有 $\log^2 a$ 个区间而不是 $n^2$ 个。

为什么是最大和最小而不是最小和最大？前后缀 gcd 都相等的情况下，你当然会考虑让中间的 gcd 尽可能大，这个时候应该尽量减小区间长度

比较优秀的写法是预处理出所有这样的特殊左端点和特殊右端点。然后枚举这些端点，这样可以在 $O(n\log^2 n + \log^3n)$ 内求解。赛时直接只优化了一边，还是没有预处理的，每次都要现求，时间复杂度为 $O(n\log^3 n)$ 跑得飞快啊。

赛时的不是很优雅的写法：

```cpp
void solve() {
    int n;
    cin >> n;
    vector<int> a(n + 1);
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
    }

    vector<int> pre(n + 1), suf(n + 2), dis(n + 1);
    for (int i = 1; i <= n; ++i) {
        pre[i] = std::gcd(pre[i - 1], a[i]);
    }
    for (int i = n; i >= 1; --i) {
        suf[i] = std::gcd(suf[i + 1], a[i]);
    }
    for (int i = 2; i <= n; ++i) {
        dis[i] = a[i] - a[i - 1];
    }

    if (*max_element(dis.begin(), dis.end()) == 0 && *min_element(dis.begin(), dis.end()) == 0) {
        cout << 0 << "\n";
        return;
    }
    
    SparseTable Gcd(dis.begin() + 1, dis.end(), [](int x, int y) {
        return std::gcd(x, y);
    });

    int ans = 0;
    for (int l = 0; l <= n; ++l) {
        int r = l + 1;
        int now = gcd(pre[l], suf[r]);
        ans = max(ans, std::gcd(now, Gcd(l + 2, r - 1)));
        while (true) {
            // find next r
            int lo = r + 1, hi = n + 1, res = -1;
            while (lo <= hi) {
                int mid = (lo + hi) >> 1;
                if (gcd(pre[l], suf[mid]) != now) {
                    res = mid, hi = mid - 1;
                } else lo = mid + 1;
            }
            if (res == -1) break;
            now = gcd(pre[l], suf[r = res]);
            ans = max(ans, std::gcd(now, Gcd(l + 2, r - 1)));
        }
    }
    cout << ans << "\n";
}
```

重制版，预处理特殊左右端点：

```cpp
void Thephix() {
    int n, single = 1;
    cin >> n;
    vector<int> a(n + 1);
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        single &= a[i] == a[1];
    }

    if (single) {
        cout << "0\n";
        return;
    }

    vector<int> dis(n + 1);
    for (int i = 2; i <= n; ++i) {
        dis[i] = a[i] - a[i - 1];
    }

    SparseTable Gcd(dis.begin() + 1, dis.end(), [](int x, int y) {
        return std::gcd(x, y);
    });

    vector<int> pre(n + 1), suf(n + 2);
    for (int i = 1; i <= n; ++i) {
        pre[i] = std::gcd(pre[i - 1], a[i]);
    }
    for (int i = n; i >= 1; --i) {
        suf[i] = std::gcd(suf[i + 1], a[i]);
    }
    
    vector<int> L {n}, R {1};
    while (L.back() != 0) {
        int p = L.back();
        int l = 0, r = p - 1, res = -1;
        while (l <= r) {
            int m = (l + r) >> 1;
            if (pre[m] != pre[p]) {
                res = m, l = m + 1;
            } else r = m - 1;
        }
        assert(res != -1);
        L.push_back(res);
    }

    while (R.back() != n + 1) {
        int p = R.back();
        int l = p + 1, r = n + 1, res = -1;
        while (l <= r) {
            int m = (l + r) >> 1;
            if (suf[m] != suf[p]) {
                res = m, r = m - 1;
            } else l = m + 1;
        }
        assert(res != -1);
        R.push_back(res);
    }

    int ans = 0;
    for (auto l : L) {
        for (auto r : R) {
            if (l >= r) continue;
            int res = std::gcd(pre[l], suf[r]);
            if (l + 2 <= r - 1) {
                res = std::gcd(res, Gcd(l + 2, r - 1));
            }
            ans = max(ans, res);
        }
    }
    cout << ans << "\n";
}
```

## C. Stack

先说赛时的想法：

注意到操作得到的序列的最后一位一定是原序列的最后一位，所以考虑枚举最后一个数字 $k$。又因为大于 $k$ 的数字只要放在无论放在哪都是等效的，所以我们不考虑 $(k, n]$ 范围内的数字。

这样我们只需要考虑以 $k$ 结尾的长度为 $k$ 的排列即可。最后考虑以 $k$ 结尾的长度为 $n$ 的序列时，只需要将 $(k, n]$ 的 $k$ 个数字插入到前面即可。方案数是合并长度分别为 $k - 1$ 和 $n - k$ 的方案数，以及将 $n - k$ 个数字排列的方案数，两个方案数相乘，答案为 $A_{n-1}^{n-k}$。

> 合并长度为 $n$, $m$ 的两个序列的方案数是隔板法。相当于将 $n$ 个物品放到 $m + 1$ 个箱子里，每个箱子可以没有物品，计算得到方案数是 $\binom{n + m}{n}$。

记长度为 $n$ 的以 $n$ 结尾的排列的种类数为 $f_0(n)$，那么考虑枚举上一个数字 $k$，那么一定是由 $f_0(k)$ 转移过来，每个序列在结尾填上 $n$ 之后，将 $n - k - 1$ 个数字和前面的长度为 $k-1$ 的序列合并，方案数是 $A_{n - 2}^{n - k - 1}$，理由和上面的类似。但是需要注意这里 $n$ 是固定在序列结尾的，但是上面的数字 $n$ 可以随便放，这里有点不太一样。于是：

$$
\begin{aligned}
f_0(n) =&
\begin{cases}
&\sum\limits_{i=1}^{n-1} f_0(i)\cdot A_{n-2}^{n-i-1} & n > 1\\
&1 &n = 1
\end{cases}\\
=&
\begin{cases}
&(n-2)!\cdot\sum\limits_{i=1}^{n-1} \frac{f_0(i)}{(i-1)!} & n > 1\\
&1 &n = 1
\end{cases}\\
\end{aligned}
$$

按照类似的思路，可以得出：

长度为 $n$ 的以 $n$ 结尾的排列产生的操作序列长度和 $f_1(n)$ 满足：

$$
f_1(n) =
\begin{cases}
&(n-2)!\cdot\sum\limits_{i = 1}^{n - 1} \frac{f_1(i) + f_0(i)}{(i-1)!} &n>1\\
&1&n=1
\end{cases}
$$

长度为 $n$ 的以 $n$ 结尾的排列产生的操作序列长度平方和 $f_2(n)$ 满足：

$$
f_2(n) =
\begin{cases}
&(n-2)!\cdot\sum\limits_{i = 1}^{n - 1} \frac{f_2(i) + 2f_1(i) + f_0(i)}{(i-1)!} &n>1\\
&1&n=1
\end{cases}
$$

长度为 $n$ 的以 $n$ 结尾的排列产生的操作序列长度立方和 $f_3(n)$ 满足：

$$
f_3(n) =
\begin{cases}
&(n-2)!\cdot\sum\limits_{i = 1}^{n - 1} \frac{f_3(i) + 3f_2(i) + 3f_3(i) + f_0(i)}{(i-1)!}&n>1\\
&1&n=1
\end{cases}
$$

最终所有长度为 $n$ 的排列产生的操作序列的立方和为：

$$
\begin{aligned}
\operatorname{ans}(n) &= \sum\limits_{i=1}^n f_3(i)\cdot A_{n-1}^{n-i}\\
&=(n-1)!\sum\limits_{i=1}^n \frac{f_3(i)}{(i-1)!}
\end{aligned}
$$

发现每个 $f(i)$ 的分母上都有一个 $(i - 1)!$，那么设 $F_1(n) = \frac{f_1(n)}{(n-1)!}$，$F_2(n) = \frac{f_2(n)}{(n-1)!}$，$F_3(n) = \frac{f_3(n)}{(n-1)!}$，于是：

$$
\begin{aligned}
F_0(1)=&F_1(1)= F_2(1)=F_3(1)=1\\
F_0(n)=&\frac{1}{n-1}\sum\limits_{i=1}^{n-1}F_0(i)\\
F_1(n)=&\frac{1}{n-1}\sum\limits_{i=1}^{n-1}(F_1(i)+F_0(i))\\
F_2(n)=&\frac{1}{n-1}\sum\limits_{i=1}^{n-1}(F_2(i)+2F_1(i)+F_0(i))\\
F_3(n)=&\frac{1}{n-1}\sum\limits_{i=1}^{n-1}(F_3(i)+3F_2(i)+3F_1(i)+F_0(i))\\
\operatorname{ans}(n)=&(n-1)!\sum\limits_{i=1}^n F_3(i)
\end{aligned}
$$

推到这里已经可以写代码了，可以继续往下推，不过不能优化，可以锻炼一下推式子的能力。预处理之后直接输出即可。下面的 $F(n)$ 是上面的 $F(n)$ 的前缀和。

```cpp
const int N = 500000;
array<Z, N + 1> F0, F1, F2, F3;

void Thephix() {
    int n; cin >> n;
    cout << F3[n] * comb.fac(n - 1) << "\n";
}

int main() {
    cin.tie(0), cout.tie(0);
    ios::sync_with_stdio(0);

    int T = 1;
    cin >> T;

    F0[1] = F1[1] = F2[1] = F3[1] = 1;
    for (int i = 2; i <= N; ++i) {
        F0[i] = F0[i - 1] + ((F0[i - 1]) * comb.inv(i - 1));
        F1[i] = F1[i - 1] + ((F1[i - 1] + F0[i - 1]) * comb.inv(i - 1));
        F2[i] = F2[i - 1] + ((F2[i - 1] + 2 * F1[i - 1] + F0[i - 1]) * comb.inv(i - 1));
        F3[i] = F3[i - 1] + ((F3[i - 1] + 3 * F2[i - 1] + 3 * F1[i - 1] + F0[i - 1]) * comb.inv(i - 1));
    }

    while (T--) {
        Thephix();
    }

    return 0;
}
```

题解的解法：

我们让 $f(p)$ 表示排列 $p$ 经过操作后得到的序列的长度，那么： 

$$
f(p) = \sum\limits_{i = 1}^n [i 在栈中出现]
$$

那么枚举所有排列，答案为：

$$
\begin{aligned}
&\sum\limits_{p} f^3(p)\\
=&\sum_{p}(\sum_{i = 1}^n [i 在栈中出现])^3\\
=&\sum_{p}(\sum_{(i, j, k)} [i 在栈中出现][j 在栈中出现][k 在栈中出现])\\
=&\sum_{(i, j, k)}\sum_{p} ([i 在栈中出现][j 在栈中出现][k 在栈中出现])\\
\end{aligned}
$$

意思是，枚举三元组 $(i, j, k)$，需要计算三元组 $(i, j, k)$ 同时在栈中出现的排列有多少个。

如果是枚举二元组 $(i, j)$，我们常见的思路是：

$$
\begin{aligned}
&\sum_{(i, j)}\sum_{p} ([i 在栈中出现][j 在栈中出现])\\
=& \sum_{i = 1}^n \sum_{p}[i 在栈中出现] + 2\cdot\sum_{i = 1}^n\sum_{j = i + 1}^n (\sum_{p}[i 在栈中出现][j 在栈中出现])
\end{aligned}
$$

如果是三个的话，也是类似的。我们记 $x < y < z$，那么所有的三元组一共就以下的几种情况：

$$
\begin{matrix}
(x & x & x)\\
\\
(x & x & y)\\
(x & y & x)\\
(y & x & x)\\
(x & y & y)\\
(y & x & y)\\
(y & y & x)\\
\\
(x & y & z)\\
(x & z & y)\\
(y & x & z)\\
(y & z & x)\\
(z & x & y)\\
(z & y & x)\\
\end{matrix}
$$

所以：

$$
\begin{aligned}
&\sum_{(i, j, k)}\sum_{p} ([i 在栈中出现][j 在栈中出现][k 在栈中出现])\\
=& 1\cdot\sum_{i = 1}^n \sum_{p}[i 在栈中出现]\\
+& 6\cdot\sum_{i = 1}^n\sum_{j = i + 1}^n (\sum_{p}[i 在栈中出现][j 在栈中出现])\\
+& 6\cdot\sum_{i = 1}^n\sum_{j = i + 1}^n\sum_{k = j + 1}^n (\sum_{p}[i 在栈中出现][j 在栈中出现][k 在栈中出现])
\end{aligned}
$$

所以我们只需要求出上面的三大坨和式的表达式即可。

考虑 $i$ 在栈中出现的情况。小于 $i$ 的部分一定出现在 $i$ 的前面，方案数为 $(i - 1)!$，大于 $i$ 的部分可以随便放，方案数已经解释过了是 $A_n^{n - i}$，所以：

$$
\sum_{p}[i 在栈中出现] = (n-1)!\cdot\frac{n!}{i!} = \frac{n!}{i}\\
\sum_{i = 1}^n \sum_{p}[i 在栈中出现] = n!\sum_{i=1}^n \frac{1}{i};
$$

类似地，我们可以求出 $i, j$ 在栈中出现的方案数为 $(i-1)!A_{j - 1}^{j - i - 1}A_{n}^{n-j} = \frac{n!}{ij}$。$i, j, k$ 在栈中出现的方案数为 $(i-1)!A_{j - 1}^{j - i - 1}A_{k - 1}^{k - j - 1}A_{n}^{n-k} = \frac{n!}{ijk}$。

于是答案就是：

$$
n!(\sum_{i=1}^n\frac{1}{i} + 6\sum_{i=1}^n\sum_{j=i+1}^n\frac{1}{ij} + 6\sum_{i=1}^n\sum_{j=i+1}^n\sum_{k=j+1}^n\frac{1}{ijk})
$$

这个东西计算需要再调整一下式子，没什么难度这里就直接算了。

```cpp
array<Z, N + 1> I, IJ, IJK;

void Thephix() {
    int n; cin >> n;
    cout << comb.fac(n) * (I[n] + 6 * IJ[n] + 6 * IJK[n]) << "\n";
}

int main() {
    cin.tie(0), cout.tie(0);
    ios::sync_with_stdio(0);

    int T = 1;
    cin >> T;

    for (int i = 1; i <= N; ++i) {
        if (i > 0) I[i] = I[i - 1] + comb.inv(i);
        if (i > 1) IJ[i] = IJ[i - 1] + I[i - 1] * comb.inv(i);
        if (i > 2) IJK[i] = IJK[i - 1] + IJ[i - 1] * comb.inv(i);
    }

    while (T--) {
        Thephix();
    }

    return 0;
}
```

斯特林数解：

用栈中的数字分割排列，可以得到一个轮换。轮换和排列是一一对应的。所以就可以得到：

$$
f(p) = \sum\limits_{k=1}^{n} k^3 {n \brack k}
$$

我们记：

$$
f_3(p) = \sum\limits_{k=1}^{n} k^3 {n \brack k}\\
f_2(p) = \sum\limits_{k=1}^{n} k^2 {n \brack k}\\
f_1(p) = \sum\limits_{k=1}^{n} k^1 {n \brack k}\\
f_0(p) = \sum\limits_{k=1}^{n} k^0 {n \brack k}
$$

那么 $f_3(1) = f_2(1) = f_1(1) = f_0(1) = 1$，且当 $n \geq 2$ 时：

$$
\begin{aligned}
f_3(n) &= \sum_{k=1}^{n} k^3 {n\brack k}\\
&= \sum_{k=1}^{n} k^3 ((n-1){n - 1\brack k} + {n - 1\brack k - 1})\\
&= (n-1) \sum_{k=1}^n k^3{n - 1\brack k} + \sum_{k=1}^nk^3{n - 1\brack k - 1}\\
&= (n-1)\cdot f_3(n-1) + \sum_{k=0}^{n-1}(k+1)^3{n - 1\brack k} 
\end{aligned}
$$

由于 $n - 1 \geq 1$，所以 ${n - 1\brack 0} = 0$，那么：

$$
\begin{aligned}
f_3(n) &= (n-1)\cdot f_3(n-1) + \sum_{k=1}^{n-1}(k+1)^3{n - 1\brack k}\\
&= (n-1)\cdot f_3(n-1) + \sum_{k=1}^{n-1}(k^3+3k^2+3k+1){n - 1\brack k}\\
&= (n-1)\cdot f_3(n-1) + (f_3(n-1) + 3f_2(n-1) + 3f_1(n-1) + f_0(n-1))\\
&= nf_3(n-1) + 3f_2(n-1) + 3f_1(n-1) + f_0(n-1)
\end{aligned}
$$

类似地，可以推出：

$$
\begin{aligned}
f_2(n)&=nf_2(n-1)+2f_1(n-1)+f_0(n-1)\\
f_1(n)&=nf_1(n-1)+f_0(n-1)\\
f_0(n)&=nf_0(n-1)\\
\end{aligned}
$$

这样就做完了。这题解法好像有点过多了，就介绍这些吧。

```cpp
array<Z, N + 1> f0, f1, f2, f3;

void Thephix() {
    int n; cin >> n;
    cout << f3[n] << "\n";
}

int main() {
    cin.tie(0), cout.tie(0);
    ios::sync_with_stdio(0);

    int T = 1;
    cin >> T;
    
    f0[1] = f1[1] = f2[1] = f3[1] = 1;
    for (int i = 2; i <= N; ++i) {
        f0[i] = i * f0[i - 1];
        f1[i] = i * f1[i - 1] + f0[i - 1];
        f2[i] = i * f2[i - 1] + 2 * f1[i - 1] + f0[i - 1];
        f3[i] = i * f3[i - 1] + 3 * f2[i - 1] + 3 * f1[i - 1] + f0[i - 1];
    }

    while (T--) {
        Thephix();
    }

    return 0;
}
```

## D. Beautiful Matrix

我赛时没怎么看题目，以为直接只有值域限制和最后一个条件。但是一看这个就很差分，因为：

$$
\begin{aligned}
&a_{ij} + a_{kl} \leq a_{il} + a_{kj}\\
\Rightarrow& a_{ij} - a_{il} \leq a_{kj} - a_{kl}
\end{aligned}
$$

这个很像转化成差分数组吧，它成立的一个必要条件是：

$$
\begin{aligned}
a_{ij} - a_{i,j+1} \leq a_{kj} - a_{k,j+1}
\end{aligned}
$$

也就是差分数组中每一列都是单调递增的。事实上，这也是充分条件，因为每一列都递增，那么对于区间和递增来说也是对的，也就是第一条式子。

这样我们把其他要求构造成差分数组：

$$
\begin{aligned}
a_{i1} = 0 &\Rightarrow d_{i1} = 0\\
a_{ij} \leq a_{i,j+1} &\Rightarrow d_{i,j+1} \geq 0
\end{aligned}
$$

我当时并不知道怎么保证值域 $a_{ij} \leq m$，实际上，$a_{ij} = \sum\limits_{j=1}^{j} d_{ij} \leq m$ 又由于 $d_{ij} \leq 0$ 所有只需要考虑最后一列 $a_{in} = \sum\limits_{j=1}^{n} d_{ij}$，再由差分数组的单调性，只需要考虑最后一行即可，也就是：

$$
\sum\limits_{j=1}^{n} d_{nj} \leq m
$$

所有条件都转化完成了，总结一下就是构造一个全为非负整数的差分矩阵，第一列全是 $0$，每一列都要单调递增，并且最后一行的和要小于等于 $m$。

就是说，我们只需要构造最后一行即可，我们记 $d_{ni} = d_i$。因为每一列都是独立的，也就是说当我们在确定 $d_i$ 的时候，无论其他列怎么选，这一列的方案数都是固定的。那么不妨考虑这一列最后一位是 $x$ 的时候，这一列有多少种方案。

先考虑上面这个问题，需要构造一个长度为 $n$ 的单调递增的数组，问最后一位为 $x$ 的方案数。我们容易想到这样子 dp：$\operatorname{dp}(i, j)$ 表示：考虑数组的前 $i$ 个数，最后一位为 $j$ 的方案数。那么根据递增的性质，有：

$$
\operatorname{dp}(i, j) = \sum_{k=0}^{j}\operatorname{dp}(i-1, k)
$$

且 $\operatorname{dp}(1, i) = 1 (0\leq i\leq m)$。这条式子有点熟悉，**$k$ 阶前缀和其实对应的着一个xx三角**。这里初始数组为全 $1$ 的情况就是杨辉三角。

$$
\begin{matrix}
1&1&1&\cdots&1\\
1&2&3&\cdots&m\\
1&3&6&\cdots&\frac{m^2+m}{2}
\end{matrix}
$$

把这个式子顺时针旋转 $45\degree$ 就能看出杨辉三角了。其中第 $i$ 行第 $j$ 列的值为 $\binom{i + j-2}{i-1}$。而第 $i$ 行第 $j$ 列对应 $\operatorname{dp}(i, j - 1)$。所以 $\operatorname{dp}(i, j - 1) = \binom{i + j - 2}{i - 1}$。这样就有：$\operatorname{dp}(n, x) = \binom{n + x - 1}{n - 1}$。也就是某一列最后一位选 $x$ 的方案数是：$\binom{n + x - 1}{n - 1}$。

什么你说你没有注意力？那来点生成函数爆推式子：

设 $f_i(x) = \sum\limits_{k = 0}^{\infty} \operatorname{dp}(i, k)\cdot x^k$，那么把上面的状态转移方程用生成函数来写一下：

$$
\begin{aligned}
[x^j]f_i(x) &= \sum_{k=0}^j [x^k]f_{i-1}(x)\\
&= \sum_{k=0}^j [x^k]f_{i-1}(x) \cdot 1
\end{aligned}
$$

这里我给它配凑了一个 $1$，因为我想要做这个操作：令 $g(x) = \sum\limits_{i=0}^\infty x^i$，那么 $1 = [x^k]g(x)$。所以：

$$
\begin{aligned}
[x^j]f_i(x) &= \sum_{k=0}^j [x^k]f_{i-1}(x) \cdot 1\\
&= \sum_{k=0}^j [x^k]f_{i-1}(x) \cdot [x^{j-k}]g(x)
\end{aligned}
$$

于是你会发现这是一个卷积的形式，那么：

$$
[x^j]f_i(x) = [x^j](f_{i-1}\cdot g)(x)
$$

这样 $f_i = f_{i-1}\cdot g$。由于 $f_1 = g$，所以 $f_n = g^n$。也就是下面这条式子：

$$
\begin{aligned}
f_n(x) &= (\sum_{i=0}^\infty x^i) ^ n\\
&= (\frac{1}{1-x})^n
\end{aligned}
$$

如果你见过负二项式定理，那么你会知道：

$$
\frac{1}{(1-x)^n}=\sum_{i=0}^\infty \binom{n+i-1}{n-1} x^i
$$

也就是 $\operatorname{dp}(n, x) = \binom{n+x-1}{n-1}$。

如果你学过生成函数，那么这一定非常熟悉，这是非常典型的问题。我们构造生成函数：

$$
f(x) = \sum_{i = 0}^m \binom{n + i - 1}{n - 1}\cdot x^i
$$

那么答案为：

$$
\sum_{i=0}^m [x^i]f^{n-1}(x)
$$

使用多项式科技来求解，时间复杂度：$O(n\log n)$。如果不会多项式科技，这条式子可以强行推出来。

我们先把 $f$ 的次数从 $m$ 改到 $\infty$，不影响答案。于是：

$$
f(x) = \sum_{i=0}^\infty \binom{n+i-1}{n-1} \cdot x^i = \frac{1}{(1-x)^n}
$$

然后我们搞一下计算答案的式子，发现可以故技重施，令 $g(x) = \sum\limits_{i=0}^\infty x^i$，那么：

$$
\begin{aligned}
\operatorname{ans} &= \sum_{i=0}^m [x^i]f^{n-1}(x) \cdot 1\\
&= \sum_{i=0}^m [x^i]f^{n-1}(x) \cdot [x^{m-i}]g(x)\\
&= [x^m] (f^{n-1}\cdot g)(x)
\end{aligned}
$$

又

$$
\begin{aligned}
f^{n-1}\cdot g(x) &= (\frac{1}{(1-x)^n})^{n-1} \cdot \frac{1}{1-x}\\
&= \frac{1}{(1-x)^{n(n-1)+1}}\\
&= \sum_{i=0}^\infty \binom{n(n-1) + i}{n(n-1)} \cdot x^i
\end{aligned}
$$

所以

$$
\operatorname{ans} = \binom{n(n-1) + m}{n(n-1)}
$$

计算这个组合数，上下都是 $m$ 项，可以在 $O(m)$ 的时间复杂度内求解。
