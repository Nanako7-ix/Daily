# 牛客多校 6 补题总结

以个人体感难度排序，可能存在个人差。[传送门](https://ac.nowcoder.com/acm/contest/108303)

## L. Minimum Parenthesis String

构造长度为 $2n$ 的最小的合法括号序，满足给定的 $m$ 的区间中，每个区间都至少包含一个左括号。

考虑贪心，如果不考虑区间的限制，显然左半边放左括号，右半边放右括号是最优的。这些区间的限制就是我们必须把前半部分的括号交换到后面，每次交换显然交换最后一个左括号。每次交换都会使得前面的左括号数量减小，也就是字典序减小，所以我们应该优先尽可能少交换。怎么尽可能少交换呢，我们直接倒序枚举区间，当下一个区间的右端点比之前区间的左端点要小的时候，结算右边的区间即可。

最后 check 一下通过这种方式构造出来的括号序是否合法。如果不合法就一定没有合法的了，因为这是尽可能让字典序最小的，也就是左括号尽可能在左边。如果这种情况都不行，那把其他的左括号放到右边就更不行了。所以实际上最小和合法是两个相似的要求。

```cpp
void Thephix() {
    int n, m;
    cin >> n >> m;
    vector<array<int, 2>> a(m + 1);
    for (int i = 1; i <= m; ++i) {
        cin >> a[i][0] >> a[i][1];
    }
    sort(a.begin() + 1, a.end(), [](const array<int, 2>& x, const array<int, 2>& y) {
        return x[1] > y[1];
    });
    
    string s = " " + string(n, '(') + string(n, ')');
    
    for (int i = 1, j = n, Max = -1; i <= m; ++i) {
        auto [l, r] = a[i];
        if (r < Max) {
            if (j <= 0) {
                cout << "-1\n";
                return;
            }
            swap(s[j], s[Max]);
            j--, Max = -1;
        }
        Max = max(Max, l);
        if (i == m) {
            if (j <= 0) {
                cout << "-1\n";
                return;
            }
            swap(s[j], s[Max]);
            j--, Max = -1;
        }
    }
    
    auto check = [&]() -> bool {
        vector<int> f(2 * n + 1);
        for (int i = 1; i <= 2 * n; ++i) {
            f[i] = s[i] == ')' ? -1 : 1;
            f[i] += f[i - 1];
            if (f[i] < 0) return false;
        }
        return true;
    };
    
    if (check()) {
        cout << s.substr(1) << "\n";
    } else {
        cout << "-1\n";
    }
}
```

## K. Maximum GCD

选择一个区间进行区间加，问区间加之后的数组的 gcd 最大是多少。先考虑我们操作的这个区间的答案，也就是区间 gcd。首先是一个 gcd 的常见结论：$\gcd(x, y) = \gcd(x, y - x)$。而区间加不会改变区间中任意两个数的差值，所以我们可以考虑通过这个性质来求解区间 gcd。

首先我们注意到如果区间中的数字相同的话，是可以做到区间 gcd 为 $\infty$ 的，而如果区间中只有两个数，那么区间的 gcd 一定会是 $|x-y|$ 的因子。类似地，我们可以得出在若干个数字的时候，区间 gcd 一定是

$$
d = \gcd\limits_{i = l+1}^{r}a_i - a_{i-1}
$$

的因子。事实上，我们可以通过区间加来使得区间 gcd 等于 $d$。操作起来很简单，只需要让最小的那个数变成 $d$ 的倍数。由于任意两个数的差值都是 $d$ 的倍数，所以每个数都是 $d$ 的倍数，这样区间 gcd 就是 $d$ 的倍数了。即使因数又是倍数，那区间 gcd 就是 $d$ 了。

于是你学会了 $n^2 \log n$ 的解法。枚举区间，对这个区间执行区间加后所能得到的最大全局 gcd 为：前缀 gcd，后缀 gcd，以及差分数组的区间 gcd 三者的 gcd。

前缀 gcd 和后缀 gcd 可以预处理，区间 gcd 用 ST 表解决。

这个时间复杂度太大了，怎么优化呢。计算答案的时间复杂度已经很优了，只能考虑优化枚举区间。这个时候有 gcd 的一个经典结论：累计的 gcd 最多变化 $\log$ 次。

累计的 gcd 就是像这里的前缀 gcd 和后缀 gcd 一样，每次都从前面的 gcd 继承过来。这样 gcd 每次变化，每次变化都会让 gcd 的质因子幂次和至少减 $1$。而 gcd 的质因子幂次和是 $\log$ 级别的。

所以我们可以把枚举 $l, r$ 改成只需要考虑使得 $\operatorname{pre}(l) = x$ 的最大的 $l$ 和使得 $\operatorname{suf}(r) = y$ 的最小的 $r$ 即可。这样实际上只会有 $\log^2 a$ 个区间而不是 $n^2$ 个。

为什么是最大和最小而不是最小和最大？前后缀 gcd 都相等的情况下，你当然会考虑让中间的 gcd 尽可能大，这个时候应该尽量减小区间长度

比较优秀的写法是预处理出所有这样的特殊左端点和特殊右端点。然后枚举这些端点，这样可以在 $O(n\log^2 n + \log^3n)$ 内求解。赛时直接只优化了一边，还是没有预处理的，每次都要现求，时间复杂度为 $O(n\log^3 n)$ 跑得飞快啊。

赛时的不是很优雅的写法：

```cpp
void solve() {
    int n;
    cin >> n;
    vector<int> a(n + 1);
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
    }

    vector<int> pre(n + 1), suf(n + 2), dis(n + 1);
    for (int i = 1; i <= n; ++i) {
        pre[i] = std::gcd(pre[i - 1], a[i]);
    }
    for (int i = n; i >= 1; --i) {
        suf[i] = std::gcd(suf[i + 1], a[i]);
    }
    for (int i = 2; i <= n; ++i) {
        dis[i] = a[i] - a[i - 1];
    }

    if (*max_element(dis.begin(), dis.end()) == 0 && *min_element(dis.begin(), dis.end()) == 0) {
        cout << 0 << "\n";
        return;
    }
    
    SparseTable Gcd(dis.begin() + 1, dis.end(), [](int x, int y) {
        return std::gcd(x, y);
    });

    int ans = 0;
    for (int l = 0; l <= n; ++l) {
        int r = l + 1;
        int now = gcd(pre[l], suf[r]);
        ans = max(ans, std::gcd(now, Gcd(l + 2, r - 1)));
        while (true) {
            // find next r
            int lo = r + 1, hi = n + 1, res = -1;
            while (lo <= hi) {
                int mid = (lo + hi) >> 1;
                if (gcd(pre[l], suf[mid]) != now) {
                    res = mid, hi = mid - 1;
                } else lo = mid + 1;
            }
            if (res == -1) break;
            now = gcd(pre[l], suf[r = res]);
            ans = max(ans, std::gcd(now, Gcd(l + 2, r - 1)));
        }
    }
    cout << ans << "\n";
}
```

重制版，预处理特殊左右端点：

```cpp
void Thephix() {
    int n, single = 1;
    cin >> n;
    vector<int> a(n + 1);
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        single &= a[i] == a[1];
    }

    if (single) {
        cout << "0\n";
        return;
    }

    vector<int> dis(n + 1);
    for (int i = 2; i <= n; ++i) {
        dis[i] = a[i] - a[i - 1];
    }

    SparseTable Gcd(dis.begin() + 1, dis.end(), [](int x, int y) {
        return std::gcd(x, y);
    });

    vector<int> pre(n + 1), suf(n + 2);
    for (int i = 1; i <= n; ++i) {
        pre[i] = std::gcd(pre[i - 1], a[i]);
    }
    for (int i = n; i >= 1; --i) {
        suf[i] = std::gcd(suf[i + 1], a[i]);
    }
    
    vector<int> L {n}, R {1};
    while (L.back() != 0) {
        int p = L.back();
        int l = 0, r = p - 1, res = -1;
        while (l <= r) {
            int m = (l + r) >> 1;
            if (pre[m] != pre[p]) {
                res = m, l = m + 1;
            } else r = m - 1;
        }
        assert(res != -1);
        L.push_back(res);
    }

    while (R.back() != n + 1) {
        int p = R.back();
        int l = p + 1, r = n + 1, res = -1;
        while (l <= r) {
            int m = (l + r) >> 1;
            if (suf[m] != suf[p]) {
                res = m, r = m - 1;
            } else l = m + 1;
        }
        assert(res != -1);
        R.push_back(res);
    }

    int ans = 0;
    for (auto l : L) {
        for (auto r : R) {
            if (l >= r) continue;
            int res = std::gcd(pre[l], suf[r]);
            if (l + 2 <= r - 1) {
                res = std::gcd(res, Gcd(l + 2, r - 1));
            }
            ans = max(ans, res);
        }
    }
    cout << ans << "\n";
}
```

## C. Stack

先说赛时的想法：

注意到操作得到的序列的最后一位一定是原序列的最后一位，所以考虑枚举最后一个数字 $k$。又因为大于 $k$ 的数字只要放在无论放在哪都是等效的，所以我们不考虑 $(k, n]$ 范围内的数字。

这样我们只需要考虑以 $k$ 结尾的长度为 $k$ 的排列即可。最后考虑以 $k$ 结尾的长度为 $n$ 的序列时，只需要将 $(k, n]$ 的 $k$ 个数字插入到前面即可。方案数是合并长度分别为 $k - 1$ 和 $n - k$ 的方案数，以及将 $n - k$ 个数字排列的方案数，两个方案数相乘，答案为 $A_{n-1}^{n-k}$。

> 合并长度为 $n$, $m$ 的两个序列的方案数是隔板法。相当于将 $n$ 个物品放到 $m + 1$ 个箱子里，每个箱子可以没有物品，计算得到方案数是 $\binom{n + m}{n}$。

记长度为 $n$ 的以 $n$ 结尾的排列的种类数为 $f_0(n)$，那么考虑枚举上一个数字 $k$，那么一定是由 $f_0(k)$ 转移过来，每个序列在结尾填上 $n$ 之后，将 $n - k - 1$ 个数字和前面的长度为 $k-1$ 的序列合并，方案数是 $A_{n - 2}^{n - k - 1}$，理由和上面的类似。但是需要注意这里 $n$ 是固定在序列结尾的，但是上面的数字 $n$ 可以随便放，这里有点不太一样。于是：

$$
\begin{aligned}
f_0(n) =&
\begin{cases}
&\sum\limits_{i=1}^{n-1} f_0(i)\cdot A_{n-2}^{n-i-1} & n > 1\\
&1 &n = 1
\end{cases}\\
=&
\begin{cases}
&(n-2)!\cdot\sum\limits_{i=1}^{n-1} \frac{f_0(i)}{(i-1)!} & n > 1\\
&1 &n = 1
\end{cases}\\
\end{aligned}
$$

按照类似的思路，可以得出：

长度为 $n$ 的以 $n$ 结尾的排列产生的操作序列长度和 $f_1(n)$ 满足：

$$
f_1(n) =
\begin{cases}
&(n-2)!\cdot\sum\limits_{i = 1}^{n - 1} \frac{f_1(i) + f_0(i)}{(i-1)!} &n>1\\
&1&n=1
\end{cases}
$$

长度为 $n$ 的以 $n$ 结尾的排列产生的操作序列长度平方和 $f_2(n)$ 满足：

$$
f_2(n) =
\begin{cases}
&(n-2)!\cdot\sum\limits_{i = 1}^{n - 1} \frac{f_2(i) + 2f_1(i) + f_0(i)}{(i-1)!} &n>1\\
&1&n=1
\end{cases}
$$

长度为 $n$ 的以 $n$ 结尾的排列产生的操作序列长度立方和 $f_3(n)$ 满足：

$$
f_3(n) =
\begin{cases}
&(n-2)!\cdot\sum\limits_{i = 1}^{n - 1} \frac{f_3(i) + 3f_2(i) + 3f_3(i) + f_0(i)}{(i-1)!}&n>1\\
&1&n=1
\end{cases}
$$

最终所有长度为 $n$ 的排列产生的操作序列的立方和为：

$$
\begin{aligned}
\operatorname{ans}(n) &= \sum\limits_{i=1}^n f_3(i)\cdot A_{n-1}^{n-i}\\
&=(n-1)!\sum\limits_{i=1}^n \frac{f_3(i)}{(i-1)!}
\end{aligned}
$$

发现每个 $f(i)$ 的分母上都有一个 $(i - 1)!$，那么设 $F_1(n) = \frac{f_1(n)}{(n-1)!}$，$F_2(n) = \frac{f_2(n)}{(n-1)!}$，$F_3(n) = \frac{f_3(n)}{(n-1)!}$，于是：

$$
\begin{aligned}
F_0(1)=&F_1(1)= F_2(1)=F_3(1)=1\\
F_0(n)=&\frac{1}{n-1}\sum\limits_{i=1}^{n-1}F_0(i)\\
F_1(n)=&\frac{1}{n-1}\sum\limits_{i=1}^{n-1}(F_1(i)+F_0(i))\\
F_2(n)=&\frac{1}{n-1}\sum\limits_{i=1}^{n-1}(F_2(i)+2F_1(i)+F_0(i))\\
F_3(n)=&\frac{1}{n-1}\sum\limits_{i=1}^{n-1}(F_3(i)+3F_2(i)+3F_1(i)+F_0(i))\\
\operatorname{ans}(n)=&(n-1)!\sum\limits_{i=1}^n F_3(i)
\end{aligned}
$$

推到这里已经可以写代码了，可以继续往下推，不过不能优化，可以锻炼一下推式子的能力。预处理之后直接输出即可。下面的 $F(n)$ 是上面的 $F(n)$ 的前缀和。

```cpp
const int N = 500000;
array<Z, N + 1> F0, F1, F2, F3;

void Thephix() {
    int n; cin >> n;
    cout << F3[n] * comb.fac(n - 1) << "\n";
}

int main() {
    cin.tie(0), cout.tie(0);
    ios::sync_with_stdio(0);

    int T = 1;
    cin >> T;

    F0[1] = F1[1] = F2[1] = F3[1] = 1;
    for (int i = 2; i <= N; ++i) {
        F0[i] = F0[i - 1] + ((F0[i - 1]) * comb.inv(i - 1));
        F1[i] = F1[i - 1] + ((F1[i - 1] + F0[i - 1]) * comb.inv(i - 1));
        F2[i] = F2[i - 1] + ((F2[i - 1] + 2 * F1[i - 1] + F0[i - 1]) * comb.inv(i - 1));
        F3[i] = F3[i - 1] + ((F3[i - 1] + 3 * F2[i - 1] + 3 * F1[i - 1] + F0[i - 1]) * comb.inv(i - 1));
    }

    while (T--) {
        Thephix();
    }

    return 0;
}
```

题解的解法：

我们让 $f(p)$ 表示排列 $p$ 经过操作后得到的序列的长度，那么： 

$$
f(p) = \sum\limits_{i = 1}^n [i 在栈中出现]
$$

那么枚举所有排列，答案为：

$$
\begin{aligned}
&\sum\limits_{p} f^3(p)\\
=&\sum_{p}(\sum_{i = 1}^n [i 在栈中出现])^3\\
=&\sum_{p}(\sum_{(i, j, k)} [i 在栈中出现][j 在栈中出现][k 在栈中出现])\\
=&\sum_{(i, j, k)}\sum_{p} ([i 在栈中出现][j 在栈中出现][k 在栈中出现])\\
\end{aligned}
$$

意思是，枚举三元组 $(i, j, k)$，需要计算三元组 $(i, j, k)$ 同时在栈中出现的排列有多少个。

如果是枚举二元组 $(i, j)$，我们常见的思路是：

$$
\begin{aligned}
&\sum_{(i, j)}\sum_{p} ([i 在栈中出现][j 在栈中出现])\\
=& \sum_{i = 1}^n [i 在栈中出现] + 2\cdot\sum_{i = 1}^n\sum_{j = i + 1}^n ([i 在栈中出现][j 在栈中出现])
\end{aligned}
$$

如果是三个的话，也是类似的，
