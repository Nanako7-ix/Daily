# 牛客多校 5 补题总结

[传送门](https://ac.nowcoder.com/acm/contest/108302)

## I. Block Combination Minimal Perimeter

手玩一下样例 $n = 5$ 就能发现，答案是由 $(1, 4)$ $(2, 3)$, $(5)$ 这三个大小为 $1 \times 5$ 的矩形组成的，周长最小就是尽量变成一个方的，所以应该是构造一个 $3 \times 5$ 的矩形。

所以直接分奇偶来计算：

奇数就是由 $(1, n - 1), (2, n - 2), \cdots, (k, n - k), (n)$ 组成，它的答案是 $2\cdot(n + k + 1)$，其中 $k$ 容易计算出是 $\lfloor\frac{n}{2}\rfloor$。

偶数就是由 $(1, n), (2, n - 1), \cdots, (k, n + 1 - k)$ 组成，它的答案是 $2\cdot(n + 1 + k)$，其中 $k = \lfloor\frac{n + 1}{2}\rfloor$

```cpp
void Thephix() {
    int n;
    cin >> n;
    cout << 2 * (n + 1 + n / 2) << "\n";
}
```

## E. Mysterious XOR Operation

既然是需要考虑 $(i, j)$ 对的，那我们不妨考虑枚举 $i$，然后对所有的 $j$ 计算一下贡献即可。对于某一位，我们容易考虑：这一位是 $0$ 还是 $1$？这一位后续 $1$ 的个数是奇数还是偶数？

显然上面这个是容易求的，所以我们只需要想想枚举 $i$ 的时候，怎么利用这个计算贡献。对于一个数 $x$ 来说，$a_i$ 在这一位上需要和 $x$ 是不同的才能有贡献。此外这一位需要是第奇数个 $1$。这个怎么计算呢，灵机一动发现：如果 $a_i$ 在这后面（指第 $[0, i]$ 位）每加一个 $1$，都会导致 $x$ 在这位以后的 $1$ 的个数的奇偶性发生改变。所以如果是奇数个 $1$ 的话，需要 $x$ 和 $a_i$ 在这一位以后的 $1$ 的数量奇偶性不同。

所以很简单就有了这样的代码：

```cpp
void Thephix() {
    int n;
    cin >> n;
    vector<int> a(n + 1);
    array<array<array<i64, 2>, 2>, 30> cnt {};
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        int tot = 0;
        for (int j = 0; j < 30; ++j) {
            tot ^= a[i] >> j & 1;
            cnt[j][a[i] >> j & 1][tot & 1]++;
        }
    }

    i64 ans = 0;
    for (int i = 1; i <= n; ++i) {
        int tot = 0;
        for (int j = 0; j < 30; ++j) {
            tot ^= a[i] >> j & 1;
            cnt[j][a[i] >> j & 1][tot & 1]--;
            ans += cnt[j][(a[i] >> j & 1) ^ 1][tot ^ 1] << j;
        }
    }
    cout << ans << "\n";
}
```

## J. Fastest Coverage Problem

先导结论：一个点变成 $1$ 的时间为该点与所有初始为 $1$ 的点的曼哈顿距离的最小值。想二分，很明显吧，触发关键字了，考虑如何 check 答案是否小于等于 $dis$。

首先可能存在一部分的点，它们变成 $1$ 的时刻大于 $dis$，我们的任务是需要加一个点，使这些很坏的点变为 $1$ 的时间小于等于 $dis$。首先我们需要找点这些点，多源 bfs 预处理之后我们可以在 $O(nm)$ 的时间复杂度内找出所有的这样的点。

然后我们应该如何选取一个点使得该点距离任意一个很坏的点的曼哈顿距离都小于等于 $dis$？显然我们可以枚举所有的点来判断这个点是否满足条件。考虑我们枚举到的点是 $(x, y)$，那么所有很坏的点 $(u, v)$ 都需要满足：

$$
\begin{cases}
x + y - dis \leq u + v \leq x + y + dis\\
x - y - dis \leq u - v \leq x - y + dis\\
\end{cases}
$$

也就是需要：

$$
\begin{cases}
\max&(x + y) \leq& u + v + dis\\
\min&(x + y) \geq& u + v - dis\\
\max&(x - y) \leq& u - v + dis\\
\min&(x - y) \geq& u - v - dis\\
\end{cases}
$$

我们只需要对所有的很坏的点维护出 $\max(x + y), \min(x + y), \max(x - y), \min(x - y)$ 就可以 $O(1)$ check 一个点 $(u, v)$ 是否合法了。暴力 $O(nm)$ 枚举所有点，查看是否存在一个点合法即可。

上面的式子还能推导出另外的结果，可以 $O(1)$ 找到合法的点：

$$
\begin{cases}
\max&(x + y - dis) \leq& u + v\\
\min&(x + y + dis) \geq& u + v\\
\max&(x - y - dis) \leq& u - v\\
\min&(x - y + dis) \geq& u - v\\
\end{cases}
$$

这样我们有了 $u + v$ 的范围，也有了 $u - v$ 的范围。如果这个范围不为空，那就有解，对吗？还需要保证 $(u, v)$ 是一个整数解。也就是当解集中只存在一个解的时候，需要判断这个解是否合法。

```cpp
constexpr int dir[4][2] = {
    {1, 0}, {-1, 0}, {0, 1}, {0, -1}
};

void Thephix() {
    int n, m;
    cin >> n >> m;
    vector<vector<int>> a  (n + 1, vector<int> (m + 1));
    vector<vector<int>> vis(n + 1, vector<int> (m + 1));
    vector<vector<i64>> dp (n + 1, vector<i64> (m + 1, 4E18));
    queue<array<int, 2>> q;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            cin >> a[i][j];
            if (a[i][j] == 1) {
                q.push({i, j});
                vis[i][j] = 1;
                dp[i][j] = 0;
            }
        }
    }
    while (!q.empty()) {
        auto [x, y] = q.front();
        q.pop();
        for (int i = 0; i < 4; ++i) {
            int tx = x + dir[i][0];
            int ty = y + dir[i][1];
            if (tx < 1 || tx > n || ty < 1 || ty > m || vis[tx][ty]) {
                continue;
            }
            dp[tx][ty] = dp[x][y] + 1;
            vis[tx][ty] = 1;
            q.push({tx, ty});
        }
    }

    auto check = [&](int dis) -> bool {
        vector<int> add, sub;
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= m; ++j) {
                if (dp[i][j] > dis) {
                    add.push_back(i + j);
                    sub.push_back(i - j);
                }
            }
        }
        if (add.size() == 0) return true;
        
        int add_min = *min_element(add.begin(), add.end());
        int add_max = *max_element(add.begin(), add.end());
        int sub_min = *min_element(sub.begin(), sub.end());
        int sub_max = *max_element(sub.begin(), sub.end());
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= m; ++j) {
                if (add_min >= i + j - dis
                 && add_max <= i + j + dis
                 && sub_min >= i - j - dis
                 && sub_max <= i - j + dis
                ) return true;
            }
        }
        return false;
    };

    auto another_check = [&](int dis) -> bool {
        int add_L = -1E9, add_R = 1E9; 
        int sub_L = -1E9, sub_R = 1E9; 
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= m; ++j) {
                if (dp[i][j] > dis) {
                    add_L = max(add_L, i + j - dis);
                    add_R = min(add_R, i + j + dis);
                    sub_L = max(sub_L, i - j - dis);
                    sub_R = min(sub_R, i - j + dis);
                }
            }
        }
        if (add_L == add_R && sub_L == sub_R && (add_L - sub_L) % 2 != 0) {
            return false;
        }
        return add_L <= add_R && sub_L <= sub_R;
    };
    
    int l = 0, r = n + m - 1, res = -1;
    while (l <= r) {
        int mid = (l + r) >> 1;
        if (another_check(mid)) {
            res = mid, r = mid - 1;
        } else l = mid + 1;
    }
    assert(res != -1);
    cout << res << "\n";
}
```

## A. Entangled Coins

假设当前的硬币数量为 $u$，则操作一次之后的硬币数量为 $u - x + (k - x) = u + k - 2x$，而 $x$ 的取值范围需要考虑下面的等式

$$
\begin{cases}
x \leq u\\
x \leq k\\
k - x \leq n - u\\
k - x \leq k
\end{cases}
\Rightarrow
\begin{cases}
x \leq u\\
x \leq k\\
x \geq u - n + k\\
x \geq 0
\end{cases}
\Rightarrow \max(0, u - n + k) \leq x \leq \min(u, k)
$$

于是操作后的硬币数量 $v$ 满足 $\max(k - u, u - k) \leq v \leq \min(u + k, 2n - (u + k))$ 且 $u \equiv v \pmod 2$

容易注意到 $k$ 的奇偶很重要，如果 $k$ 是奇数的话，每次操作，当前的正向硬币数量奇偶会发生改变，否则不会。

以上是我赛时的想法，我在尝试处理这个区间的变化（因为显然一个区间的 $u$ 操作后得到的 $v$ 的范围也会是一个区间）的时候感觉不是很对，这他妈能做？这个区间似乎是没有一点规律的。比如样例：

$$
\begin{matrix}
n=98257693&k=98257692&s=24&t=43850682
\end{matrix}
$$

的情况下，打表区间的变化情况，区间是左右横跳的，这就很坏了，我当时直接放弃了。

事实上，可以考虑两次操作。先把上面的区间改进一下：

$$
|u - k| \leq v \leq n - |(n - k) - u|
$$

这个时候发现整个值域被 $k$ 和 $n - k$ 分成了三块
